<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Anonomoose Chat</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css">
  <link rel="icon" type="image/png" href="https://cdnjs.cloudflare.com/ajax/libs/twemoji/14.0.2/72x72/1f60e.png"/>
  <style>
    * {
      cursor: default;
      user-select: none;
    }
    input[type="text"],
    input[type="number"],
    input[type="file"],
    textarea {
      cursor: text;
      user-select: text;
    }
    #codeDisplay {
      user-select: text;
    }
    body {
      min-height: 100vh;
      padding-top: 140px;
      padding-bottom: 140px;
    }
    #messages {
      display: flex;
      flex-direction: column-reverse;
      overflow-y: auto;
      scroll-behavior: auto;
      z-index: 0;
      margin-bottom: 0.5rem;
      border-radius: 0.5rem;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      position: relative;
      height: 296px;
      background-color: #fce7f3;
      background-image: none;
      background-size: 100% 100%;
      background-position: center;
      background-repeat: no-repeat;
    }
    #messages.waiting {
      background-color: transparent;
      background-image: url('https://raw.githubusercontent.com/Cooptroop1/anonmess/main/logo.JPG?sanitize=true');
    }
    .corner-logo {
      position: absolute;
      top: 10px;
      right: 10px;
      width: 256px;
      height: 256px;
      background-image: url('https://raw.githubusercontent.com/Cooptroop1/anonmess/main/corner%20logo.png?sanitize=true');
      background-size: contain;
      background-repeat: no-repeat;
      background-position: center;
      z-index: 100;
      transition: background-image 0.5s ease;
    }
    .corner-logo.wink {
      background-image: url('https://raw.githubusercontent.com/Cooptroop1/anonmess/main/corner%20logoWink.png?sanitize=true');
    }
    .bg-white {
      z-index: 10;
    }
    @media (min-width: 641px) and (max-width: 1024px) {
      .corner-logo {
        z-index: -1;
      }
    }
    @media (max-width: 640px) {
      .corner-logo {
        position: absolute;
        top: 10px;
        right: 10px;
        width: 128px;
        height: 128px;
        z-index: 1000;
      }
      #chatContainer:not(.hidden) #messages.waiting ~ .corner-logo {
        position: absolute;
        top: 10px;
        right: 10px;
        width: 128px;
        height: 128px;
        z-index: 1000;
      }
      #maxClientsContainer {
        position: absolute;
        bottom: -335px;
        left: 50%;
        transform: translateX(-50%);
        width: 100%;
        max-width: 360px;
        margin: 0;
        padding: 0.75rem;
        background-color: #000000;
        border-radius: 0.5rem;
        z-index: 1000;
      }
      #maxClientsRadios {
        display: grid;
        grid-template-columns: repeat(5, minmax(0, 1fr));
        gap: 0.3rem;
        justify-items: center;
      }
      #maxClientsRadios button {
        background-color: #3b82f6;
        color: white;
        border-radius: 0.5rem;
        padding: 0.4rem;
        font-size: 0.9rem;
        width: 100%;
        text-align: center;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        transition: all 0.2s ease;
      }
      #maxClientsRadios button.active {
        background-color: #10b981;
      }
      #maxClientsRadios button:hover:not(:disabled) {
        background-color: #1d4ed8;
      }
      #maxClientsRadios button:disabled {
        opacity: 0.6;
        cursor: not-allowed;
      }
    }
    .message-bubble {
      max-width: 70%;
      margin: 0.1rem 1rem;
      padding: 0.25rem 0.5rem;
      border-radius: 1rem;
      word-wrap: break-word;
      box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
      display: inline-flex;
      flex-direction: column;
      align-items: flex-start;
    }
    .message-bubble img {
      max-width: 100%;
      border-radius: 0.5rem;
      margin-top: 0.15rem;
      margin-bottom: 0.5rem;
    }
    .message-bubble.self {
      background-color: #3b82f6;
      color: white;
      margin-left: auto;
      border-bottom-right-radius: 0.25rem;
    }
    .message-bubble.other {
      background-color: #10b981;
      color: white;
      margin-right: auto;
      border-bottom-left-radius: 0.25rem;
    }
    .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.9);
      z-index: 2000;
      align-items: center;
      justify-content: center;
    }
    .modal img {
      max-width: 90%;
      max-height: 90%;
      border-radius: 0.5rem;
    }
    .modal.active {
      display: flex;
    }
    .help-modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.7);
      z-index: 2000;
      align-items: center;
      justify-content: center;
    }
    .help-modal-content {
      background-color: white;
      padding: 1.5rem;
      border-radius: 0.5rem;
      max-width: 90%;
      max-height: 90%;
      overflow-y: auto;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
    }
    .help-modal.active {
      display: flex;
    }
    #chatContainer.hidden {
      display: none;
      visibility: hidden;
    }
    #chatContainer {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
      position: relative;
    }
    .input-container {
      display: flex;
      align-items: flex-start;
      gap: 0.75rem;
      padding: 0 0.8rem;
      position: relative;
      margin-top: 0.15rem;
      width: 100%;
      box-sizing: border-box;
      z-index: 10;
    }
    .input-container.hidden {
      display: none;
    }
    #messageInput {
      resize: none;
      overflow-y: auto;
      height: 2.5rem;
      max-height: 12.5rem;
      line-height: 1.5rem;
      width: 110%;
      max-width: 110%;
      background-color: #3b82f6;
      color: white;
      border-radius: 1rem;
      padding: 0.5rem 1rem;
      border: none;
      box-sizing: border-box;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      transition: all 0.2s ease;
      margin-left: -3mm;
    }
    #imageButton {
      width: 2.5rem;
      height: 2.5rem;
      background-color: #10b981;
      color: white;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.2rem;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      transition: all 0.2s ease;
    }
    #imageButton:hover {
      background-color: #059669;
    }
    @media (max-width: 640px) {
      #messageInput {
        padding: 0.5rem 0.75rem;
      }
      .input-container {
        padding: 0 0.3rem;
      }
    }
    #messageInput::-webkit-scrollbar {
      display: none;
    }
    #messageInput {
      -ms-overflow-style: none;
      scrollbar-width: none;
    }
    #sendButton {
      width: 2.5rem;
      height: 2.5rem;
      background-color: #2563eb;
      color: white;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.2rem;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      transition: all 0.2s ease;
    }
    #sendButton:hover {
      background-color: #1d4ed8;
    }
    .button-group {
      display: flex;
      justify-content: space-between;
      margin: 0.5rem 0.8rem;
      width: calc(100% - 1.6rem);
      box-sizing: border-box;
    }
    .button-group button {
      padding: 0.35rem 0.9rem;
      border-radius: 0.375rem;
      cursor: pointer;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      transition: all 0.2s ease;
      flex: 1;
      margin: 0 0.25rem;
    }
    #button1 {
      background-color: #9b59b6;
      color: white;
      margin-left: -3.25mm;
    }
    #button1:hover {
      background-color: #8e44ad;
    }
    #button2 {
      background-color: #f1c40f;
      color: white;
    }
    #button2:hover {
      background-color: #d4a017;
    }
    #button2:disabled {
      background-color: #d4a017;
      opacity: 0.6;
      cursor: not-allowed;
    }
    #copyCodeButton {
      background-color: #10b981;
      color: white;
      margin-right: -3.25mm;
    }
    #copyCodeButton:hover {
      background-color: #059669;
    }
    #helpText {
      color: #3b82f6;
      cursor: pointer;
      transition: color 0.2s ease;
    }
    #helpText:hover {
      color: #1d4ed8;
    }
    @media (min-width: 1025px) {
      .bg-white {
        margin-top: -40px;
      }
      #maxClientsContainer {
        min-height: calc(100% + 37.8px);
        margin-top: 145px;
      }
    }
    @media (min-width: 641px) and (max-width: 1024px) {
      #maxClientsContainer {
        margin-top: 145px;
      }
    }
    @media (max-width: 640px) {
      .button-group {
        margin: 0.5rem 0.3rem;
        width: calc(100% - 0.6rem);
      }
      .button-group button {
        padding: 0.8rem 0.9rem;
        font-size: 0.9rem;
        margin: 0 0.125rem;
      }
      h1.text-3xl {
        font-size: 1.5rem;
        margin-bottom: 0.75rem;
        padding: 0.25rem 0;
      }
      #status {
        font-size: 0.875rem;
        margin-bottom: 0.5rem;
        padding: 0.25rem 0;
      }
    }
    @media (min-width: 641px) {
      #maxClientsRadios {
        display: flex;
        flex-direction: column;
        gap: 0.5rem;
        align-items: center;
      }
      #maxClientsRadios button {
        background-color: #3b82f6;
        color: white;
        border-radius: 0.5rem;
        padding: 0.5rem;
        font-size: 1rem;
        width: 60px;
        text-align: center;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        transition: all 0.2s ease;
      }
      #maxClientsRadios button.active {
        background-color: #10b981;
      }
      #maxClientsRadios button:hover:not(:disabled) {
        background-color: #1d4ed8;
      }
      #maxClientsRadios button:disabled {
        opacity: 0.6;
        cursor: not-allowed;
      }
    }
  </style>
</head>
<body class="bg-black min-h-screen flex items-center justify-center">
  <div class="corner-logo" id="cornerLogo" role="img" aria-label="Anonomoose Chat logo"></div>
  <div class="flex w-full max-w-xl">
    <div class="bg-white p-8 rounded-lg shadow-lg flex-grow">
      <h1 class="text-3xl font-bold mb-8 text-center text-gray-800">Anonomoose Chat</h1>
      <div id="status" class="text-center mb-4 text-gray-600" role="status" aria-live="polite">Start a new chat or connect to an existing one</div>
      <div id="initialContainer">
        <button id="startChatToggleButton" class="bg-blue-500 text-white px-4 py-2 rounded w-full mb-2 hover:bg-blue-600 transition-colors" aria-label="Start a new chat">Start Chat</button>
        <button id="connectToggleButton" class="bg-green-500 text-white px-4 py-2 rounded w-full hover:bg-green-600 transition-colors" aria-label="Connect to an existing chat">Connect to Chat</button>
      </div>
      <div id="usernameContainer" class="hidden">
        <label for="usernameInput" class="sr-only">Enter your username</label>
        <input id="usernameInput" type="text" class="border border-gray-300 p-2 w-full mb-2 rounded" placeholder="Enter your username (1-16 chars)" aria-describedby="usernameHelp" maxlength="16">
        <div id="usernameHelp" class="text-sm text-gray-600 mb-2">Username must be 1-16 alphanumeric characters</div>
        <button id="joinWithUsernameButton" class="bg-blue-500 text-white px-4 py-2 rounded w-full hover:bg-blue-600 transition-colors" aria-label="Join chat with username">Join Chat</button>
        <button id="backButton" class="bg-gray-500 text-white px-4 py-2 rounded w-full mt-2 hover:bg-gray-600 transition-colors" aria-label="Back to main menu">Back</button>
      </div>
      <div id="codeDisplay" class="text-center mb-4 font-mono text-lg text-gray-800 hidden" role="region" aria-live="polite"></div>
      <div id="chatContainer" class="hidden">
        <button id="newSessionButton" class="bg-red-500 text-white px-2 py-1 rounded w-full mb-1 rounded hover:bg-red-600 transition-colors hidden" aria-label="Start a new session">New Session</button>
        <div class="button-group">
          <button id="button1" aria-label="Send code to random chat board">Send Code</button>
          <button id="button2" aria-label="Join a random chat">Random Chat</button>
          <button id="copyCodeButton" aria-label="Copy chat code">Copy Code</button>
        </div>
        <div id="messages" class="border border-gray-300 p-4 h-64 overflow-y-auto mb-4 rounded" role="log" aria-live="polite"></div>
        <div class="input-container hidden">
          <label for="messageInput" class="sr-only">Type a message</label>
          <textarea id="messageInput" placeholder="Type a message..." cols="30" maxlength="1000" aria-describedby="messageHelp"></textarea>
          <div id="messageHelp" class="sr-only">Maximum 1000 characters. Press Enter to send, Shift+Enter for new line.</div>
          <input type="file" id="imageInput" accept="image/jpeg,image/png" style="display: none;" aria-label="Upload image" />
          <button id="imageButton" title="Send Image" aria-label="Send image">📷</button>
          <button id="sendButton" aria-label="Send message">📤</button>
        </div>
      </div>
      <div id="connectContainer" class="hidden">
        <label for="usernameConnectInput" class="sr-only">Enter your username</label>
        <input id="usernameConnectInput" type="text" class="border border-gray-300 p-2 w-full mb-2 rounded" placeholder="Enter your username (1-16 chars)" aria-describedby="usernameConnectHelp" maxlength="16">
        <div id="usernameConnectHelp" class="text-sm text-gray-600 mb-2">Username must be 1-16 alphanumeric characters</div>
        <label for="codeInput" class="sr-only">Enter chat code</label>
        <input id="codeInput" type="text" class="border border-gray-300 p-2 w-full mb-2 rounded" placeholder="Enter code (xxxx-xxxx-xxxx-xxxx)" aria-describedby="codeHelp" maxlength="19">
        <div id="codeHelp" class="text-sm text-gray-600 mb-2">Code format: xxxx-xxxx-xxxx-xxxx</div>
        <button id="connectButton" class="bg-green-500 text-white px-4 py-2 rounded w-full hover:bg-green-600 transition-colors" aria-label="Connect to chat">Connect</button>
        <button id="backButtonConnect" class="bg-gray-500 text-white px-4 py-2 rounded w-full mt-2 hover:bg-gray-600 transition-colors" aria-label="Back to main menu">Back</button>
      </div>
      <div class="text-center mt-4">
        <button id="helpText" class="text-blue-500 hover:underline" aria-label="View help information">Help</button>
      </div>
    </div>
    <div id="maxClientsContainer" class="hidden flex flex-col justify-center bg-black p-4 rounded-lg shadow-lg">
      <span class="text-white mb-2 font-bold">Max Users</span>
      <div id="maxClientsRadios" class="grid grid-cols-5 gap-2" role="radiogroup" aria-label="Select maximum number of users"></div>
    </div>
  </div>
  <div id="helpModal" class="help-modal" role="dialog" aria-label="Help information" tabindex="-1">
    <div class="help-modal-content">
      <h2 class="text-xl font-bold mb-4">Button Help</h2>
      <p><strong>Start Chat:</strong> Starts New Chat</p>
      <p><strong>Connect to Chat:</strong> This connects you to a chat that you have code for</p>
      <p><strong>Send Code:</strong> This sends your code to Random chat board</p>
      <p><strong>Random Chat:</strong> This takes you to random chat board for a random chat</p>
      <p><strong>Copy Code:</strong> Copies the code so you can send to people in text or social chats</p>
    </div>
  </div>
  <script>
    // Keepalive timer IDs
    let keepAliveTimer = null;
    let relayKeepAliveTimer = null;
    // Reconnection attempt counter for exponential backoff
    let reconnectAttempts = 0;
    let relayReconnectAttempts = 0;
    // Image rate limiting
    const imageRateLimits = new Map();
    // Relay server state
    let relaySocket = null;
    let isRelayMode = false;

    // Utility to show temporary status messages
    function showStatusMessage(message, duration = 3000) {
      const statusElement = document.getElementById('status');
      statusElement.textContent = message;
      statusElement.setAttribute('aria-live', 'assertive');
      setTimeout(() => {
        statusElement.textContent = isConnected ? `Connected (${totalClients}/${maxClients} connections${isRelayMode ? ' via server' : ''})` : 'Waiting for connection...';
        statusElement.setAttribute('aria-live', 'polite');
      }, duration);
    }

    // Sanitize message content to prevent XSS
    function sanitizeMessage(content) {
      const div = document.createElement('div');
      div.textContent = content;
      return div.innerHTML.replace(/</g, '<').replace(/>/g, '>');
    }

    function generateCode() {
      const chars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
      let result = '';
      for (let i = 0; i < 16; i++) {
        result += chars.charAt(Math.floor(Math.random() * chars.length));
        if (i % 4 === 3 && i < 15) result += '-';
      }
      return result;
    }

    function generateMessageId() {
      return Math.random().toString(36).substr(2, 9);
    }

    function validateUsername(username) {
      const regex = /^[a-zA-Z0-9]{1,16}$/;
      return username && regex.test(username);
    }

    function validateCode(code) {
      const regex = /^[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}-[a-zA-Z0-9]{4}$/;
      return code && regex.test(code);
    }

    async function sendImage(file) {
      const validImageTypes = ['image/jpeg', 'image/png'];
      if (!file || !validImageTypes.includes(file.type) || !username || (dataChannels.size === 0 && (!relaySocket || relaySocket.readyState !== WebSocket.OPEN))) {
        showStatusMessage('Error: Select a JPEG or PNG image and ensure you are connected.');
        document.getElementById('imageButton').focus();
        return;
      }
      if (file.size > 5 * 1024 * 1024) {
        showStatusMessage('Error: Image size exceeds 5MB limit.');
        document.getElementById('imageButton').focus();
        return;
      }

      // Image rate limiting
      const now = performance.now();
      const rateLimit = imageRateLimits.get(clientId) || { count: 0, startTime: now };
      if (now - rateLimit.startTime >= 60000) {
        rateLimit.count = 0;
        rateLimit.startTime = now;
      }
      rateLimit.count += 1;
      imageRateLimits.set(clientId, rateLimit);
      if (rateLimit.count > 5) {
        showStatusMessage('Image rate limit reached (5 images/min). Please wait.');
        document.getElementById('imageButton').focus();
        return;
      }

      const maxWidth = 640;
      const maxHeight = 360;
      const quality = 0.4;
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      const img = new Image();
      img.src = URL.createObjectURL(file);
      await new Promise(resolve => img.onload = resolve);

      let width = img.width;
      let height = img.height;
      if (width > height) {
        if (width > maxWidth) {
          height = Math.round((height * maxWidth) / width);
          width = maxWidth;
        }
      } else {
        if (height > maxHeight) {
          width = Math.round((width * maxHeight) / height);
          height = maxHeight;
        }
      }
      canvas.width = width;
      canvas.height = height;
      ctx.drawImage(img, 0, 0, width, height);
      const base64 = canvas.toDataURL('image/jpeg', quality);
      URL.revokeObjectURL(img.src);

      const messageId = generateMessageId();
      const message = { messageId, type: 'image', data: base64, username, code };
      const jsonString = JSON.stringify(message);
      if (isRelayMode) {
        if (relaySocket && relaySocket.readyState === WebSocket.OPEN) {
          relaySocket.send(jsonString);
        } else {
          showStatusMessage('Error: Not connected to server.');
          document.getElementById('imageButton').focus();
          return;
        }
      } else {
        dataChannels.forEach((dataChannel, targetId) => {
          if (dataChannel.readyState === 'open') {
            dataChannel.send(jsonString);
          }
        });
      }

      const messages = document.getElementById('messages');
      const messageDiv = document.createElement('div');
      messageDiv.className = 'message-bubble self';
      messageDiv.textContent = `${username}: `;
      const imgElement = document.createElement('img');
      imgElement.src = base64;
      imgElement.style.maxWidth = '100%';
      imgElement.style.borderRadius = '0.5rem';
      imgElement.style.cursor = 'pointer';
      imgElement.setAttribute('alt', 'Sent image');
      imgElement.addEventListener('click', () => {
        let modal = document.getElementById('imageModal');
        if (!modal) {
          modal = document.createElement('div');
          modal.id = 'imageModal';
          modal.className = 'modal';
          modal.setAttribute('role', 'dialog');
          modal.setAttribute('aria-label', 'Image viewer');
          modal.setAttribute('tabindex', '-1');
          document.body.appendChild(modal);
        }
        modal.innerHTML = '';
        const modalImg = document.createElement('img');
        modalImg.src = base64;
        modalImg.setAttribute('alt', 'Enlarged image');
        modal.appendChild(modalImg);
        modal.classList.add('active');
        modal.focus();
        modal.addEventListener('click', () => {
          modal.classList.remove('active');
          document.getElementById('imageButton').focus();
        });
        modal.addEventListener('keydown', (event) => {
          if (event.key === 'Escape') {
            modal.classList.remove('active');
            document.getElementById('imageButton').focus();
          }
        });
      });
      messageDiv.appendChild(imgElement);
      messages.prepend(messageDiv);
      messages.scrollTop = messages.scrollHeight;
      processedMessageIds.add(messageId);
      document.getElementById('imageButton').focus();
    }

    let code = generateCode();
    let clientId = localStorage.getItem('clientId');
    if (!clientId) {
      clientId = generateMessageId();
      localStorage.setItem('clientId', clientId);
    }
    let isInitiator = false;
    let isConnected = false;
    let maxClients = 2;
    let totalClients = 0;
    let peerConnections = new Map();
    let dataChannels = new Map();
    let connectionTimeouts = new Map();
    let retryCounts = new Map();
    const maxRetries = 2;
    let candidatesQueues = new Map();
    let processedMessageIds = new Set();
    let processedAnswers = new Set();
    let username = localStorage.getItem('username')?.trim() || '';
    let usernames = new Map();
    const messageRateLimits = new Map();
    let codeSentToRandom = false;

    const statusElement = document.getElementById('status');
    const codeDisplayElement = document.getElementById('codeDisplay');
    const copyCodeButton = document.getElementById('copyCodeButton');
    const initialContainer = document.getElementById('initialContainer');
    const usernameContainer = document.getElementById('usernameContainer');
    const connectContainer = document.getElementById('connectContainer');
    const chatContainer = document.getElementById('chatContainer');
    const newSessionButton = document.getElementById('newSessionButton');
    const maxClientsContainer = document.getElementById('maxClientsContainer');
    const inputContainer = document.querySelector('.input-container');
    const messages = document.getElementById('messages');
    const cornerLogo = document.getElementById('cornerLogo');
    const button2 = document.getElementById('button2');
    const helpText = document.getElementById('helpText');
    const helpModal = document.getElementById('helpModal');

    // Help modal toggle
    helpText.addEventListener('click', () => {
      helpModal.classList.add('active');
      helpModal.focus();
    });

    helpModal.addEventListener('click', () => {
      helpModal.classList.remove('active');
      helpText.focus();
    });

    helpModal.addEventListener('keydown', (event) => {
      if (event.key === 'Escape') {
        helpModal.classList.remove('active');
        helpText.focus();
      }
    });

    // Logo cycle animation
    let cycleTimeout;
    function triggerCycle() {
      if (cycleTimeout) clearTimeout(cycleTimeout);
      cornerLogo.classList.add('wink');
      cycleTimeout = setTimeout(() => {
        cornerLogo.classList.remove('wink');
      }, 500);
      setTimeout(() => triggerCycle(), 60000);
    }
    setTimeout(() => triggerCycle(), 60000);

    // Keepalive function for signaling server
    function startKeepAlive() {
      if (keepAliveTimer) clearInterval(keepAliveTimer);
      keepAliveTimer = setInterval(() => {
        if (socket.readyState === WebSocket.OPEN) {
          socket.send(JSON.stringify({ type: 'ping', clientId }));
          console.log('Sent signaling keepalive ping');
        }
      }, 20000);
    }

    function stopKeepAlive() {
      if (keepAliveTimer) {
        clearInterval(keepAliveTimer);
        keepAliveTimer = null;
        console.log('Stopped signaling keepalive');
      }
    }

    // Keepalive function for relay server
    function startRelayKeepAlive() {
      if (relayKeepAliveTimer) clearInterval(relayKeepAliveTimer);
      relayKeepAliveTimer = setInterval(() => {
        if (relaySocket && relaySocket.readyState === WebSocket.OPEN) {
          relaySocket.send(JSON.stringify({ type: 'ping', clientId }));
          console.log('Sent relay keepalive ping');
        }
      }, 20000);
    }

    function stopRelayKeepAlive() {
      if (relayKeepAliveTimer) {
        clearInterval(relayKeepAliveTimer);
        relayKeepAliveTimer = null;
        console.log('Stopped relay keepalive');
      }
    }

    // Initialize relay server connection
    function initRelaySocket() {
      console.log('Initializing relay socket');
      relaySocket = new WebSocket('wss://anonomoose-relay-server.onrender.com:10000');
      
      relaySocket.onopen = () => {
        console.log('Relay WebSocket opened');
        relaySocket.send(JSON.stringify({ type: 'connect', clientId }));
        if (code && username && validateCode(code) && validateUsername(username)) {
          console.log('Sending join to relay server for code:', code);
          relaySocket.send(JSON.stringify({ type: 'join', code, clientId, username }));
        }
        startRelayKeepAlive();
        relayReconnectAttempts = 0;
      };

      relaySocket.onmessage = (event) => {
        console.log('Received relay WebSocket message:', event.data);
        try {
          const message = JSON.parse(event.data);
          if (message.type === 'pong') {
            console.log('Received relay keepalive pong');
            return;
          }
          if (message.type === 'connected') {
            console.log(`Relay server connected, clientId: ${message.clientId}`);
            return;
          }
          if (message.type === 'error') {
            showStatusMessage(message.message);
            console.error('Relay server error:', message.message);
            if (message.message.includes('Chat is full') || message.message.includes('Username already taken')) {
              resetToInitialState();
            }
            return;
          }
          if (message.type === 'joined') {
            console.log(`Joined relay chat ${message.code}, totalClients: ${message.totalClients}`);
            totalClients = message.totalClients;
            isConnected = true;
            chatContainer.classList.remove('hidden');
            inputContainer.classList.remove('hidden');
            messages.classList.remove('waiting');
            updateMaxClientsUI();
            document.getElementById('messageInput').focus();
          }
          if (message.type === 'join-notify' && message.code === code) {
            console.log(`Relay join-notify: client ${message.clientId}, username: ${message.username}, total: ${message.totalClients}`);
            totalClients = message.totalClients;
            usernames.set(message.clientId, message.username);
            updateMaxClientsUI();
          }
          if (message.type === 'client-disconnected' && message.code === code) {
            console.log(`Relay client ${message.clientId} disconnected, total: ${message.totalClients}`);
            totalClients = message.totalClients;
            usernames.delete(message.clientId);
            updateMaxClientsUI();
            if (totalClients <= 1) {
              inputContainer.classList.add('hidden');
              messages.classList.add('waiting');
            }
          }
          if (message.type === 'message' || message.type === 'image') {
            handleRelayMessage(message);
          }
          if (message.type === 'random-code') {
            console.log(`Received random code: ${message.code}`);
            if (code !== message.code) {
              resetToInitialState();
              code = message.code;
              codeDisplayElement.textContent = `Using code: ${code}`;
              codeDisplayElement.classList.remove('hidden');
              copyCodeButton.classList.remove('hidden');
              chatContainer.classList.remove('hidden');
              messages.classList.add('waiting');
              statusElement.textContent = 'Waiting for connection...';
              if (socket.readyState === WebSocket.OPEN) {
                socket.send(JSON.stringify({ type: 'join', code, clientId, username }));
              }
              if (relaySocket && relaySocket.readyState === WebSocket.OPEN) {
                relaySocket.send(JSON.stringify({ type: 'join', code, clientId, username }));
              }
              document.getElementById('messageInput').focus();
            }
          }
        } catch (error) {
          console.error('Error parsing relay message:', error);
          showStatusMessage('Error receiving server message.');
        }
      };

      relaySocket.onerror = (error) => {
        console.error('Relay WebSocket error:', error);
        showStatusMessage('Server connection error, retrying...');
        stopRelayKeepAlive();
      };

      relaySocket.onclose = () => {
        console.error('Relay WebSocket closed, attempting reconnect');
        stopRelayKeepAlive();
        const delay = Math.min(30000, 5000 * Math.pow(2, relayReconnectAttempts));
        relayReconnectAttempts++;
        setTimeout(() => {
          initRelaySocket();
        }, delay);
      };
    }

    // Handle messages from relay server
    function handleRelayMessage(data) {
      if (!data.messageId || !data.username || (!data.content && data.type !== 'image') || (data.type === 'image' && !data.data)) {
        console.log('Invalid relay message format:', data);
        return;
      }
      if (processedMessageIds.has(data.messageId)) {
        console.log(`Duplicate relay message ${data.messageId}`);
        return;
      }
      processedMessageIds.add(data.messageId);
      const senderUsername = data.username;
      const isSelf = senderUsername === username;
      const messages = document.getElementById('messages');
      const messageDiv = document.createElement('div');
      messageDiv.className = `message-bubble ${isSelf ? 'self' : 'other'}`;
      if (data.type === 'image') {
        messageDiv.textContent = `${senderUsername}: `;
        const img = document.createElement('img');
        img.src = data.data;
        img.style.maxWidth = '100%';
        img.style.borderRadius = '0.5rem';
        img.style.cursor = 'pointer';
        img.setAttribute('alt', 'Received image');
        img.addEventListener('click', () => {
          let modal = document.getElementById('imageModal');
          if (!modal) {
            modal = document.createElement('div');
            modal.id = 'imageModal';
            modal.className = 'modal';
            modal.setAttribute('role', 'dialog');
            modal.setAttribute('aria-label', 'Image viewer');
            modal.setAttribute('tabindex', '-1');
            document.body.appendChild(modal);
          }
          modal.innerHTML = '';
          const modalImg = document.createElement('img');
          modalImg.src = data.data;
          modalImg.setAttribute('alt', 'Enlarged image');
          modal.appendChild(modalImg);
          modal.classList.add('active');
          modal.focus();
          modal.addEventListener('click', () => {
            modal.classList.remove('active');
            document.getElementById('messageInput').focus();
          });
          modal.addEventListener('keydown', (event) => {
            if (event.key === 'Escape') {
              modal.classList.remove('active');
              document.getElementById('messageInput').focus();
            }
          });
        });
        messageDiv.appendChild(img);
      } else {
        messageDiv.textContent = `${senderUsername}: ${sanitizeMessage(data.content)}`;
      }
      messages.prepend(messageDiv);
      messages.scrollTop = messages.scrollHeight;
    }

    // Check connection status and switch to relay mode if needed
    function checkConnectionStatus() {
      if (isRelayMode) {
        if (!relaySocket || relaySocket.readyState !== WebSocket.OPEN) {
          console.log('Relay socket disconnected, attempting reconnect');
          initRelaySocket();
        }
        return;
      }
      if (dataChannels.size === 0 && username && code && validateUsername(username) && validateCode(code)) {
        console.log('No active P2P connections, switching to relay mode');
        isRelayMode = true;
        showStatusMessage('Switched to server relay due to connection issues', 5000);
        if (!relaySocket || relaySocket.readyState !== WebSocket.OPEN) {
          initRelaySocket();
        }
      }
    }

    // Reset to initial state
    function resetToInitialState() {
      if (socket.readyState === WebSocket.OPEN) {
        socket.send(JSON.stringify({ type: 'leave', code, clientId }));
      }
      if (relaySocket && relaySocket.readyState === WebSocket.OPEN) {
        relaySocket.send(JSON.stringify({ type: 'leave', code, clientId }));
      }
      peerConnections.forEach((pc) => pc.close());
      dataChannels.forEach((dc) => dc.close());
      peerConnections.clear();
      dataChannels.clear();
      candidatesQueues.clear();
      connectionTimeouts.forEach((timeout) => clearTimeout(timeout));
      connectionTimeouts.clear();
      retryCounts.clear();
      processedMessageIds.clear();
      processedAnswers.clear();
      usernames.clear();
      messageRateLimits.clear();
      imageRateLimits.clear();
      isConnected = false;
      isInitiator = false;
      isRelayMode = false;
      maxClients = 2;
      totalClients = 0;
      code = generateCode();
      codeDisplayElement.textContent = '';
      codeDisplayElement.classList.add('hidden');
      copyCodeButton.classList.add('hidden');
      statusElement.textContent = 'Start a new chat or connect to an existing one';
      document.getElementById('messages').innerHTML = '';
      document.getElementById('messageInput').value = '';
      document.getElementById('messageInput').style.height = '2.5rem';
      document.getElementById('usernameInput').value = username || '';
      document.getElementById('usernameConnectInput').value = username || '';
      document.getElementById('codeInput').value = '';
      initialContainer.classList.remove('hidden');
      usernameContainer.classList.add('hidden');
      connectContainer.classList.add('hidden');
      chatContainer.classList.add('hidden');
      newSessionButton.classList.add('hidden');
      maxClientsContainer.classList.add('hidden');
      inputContainer.classList.add('hidden');
      messages.classList.remove('waiting');
      codeSentToRandom = false;
      button2.disabled = false;
      stopKeepAlive();
      stopRelayKeepAlive();
      if (relaySocket) {
        relaySocket.close();
        relaySocket = null;
      }
    }

    const socket = new WebSocket('wss://signaling-server-zc6m.onrender.com');
    console.log('WebSocket created');

    socket.onopen = () => {
      console.log('WebSocket opened');
      socket.send(JSON.stringify({ type: 'connect', clientId }));
      startKeepAlive();
      reconnectAttempts = 0;
      const urlParams = new URLSearchParams(window.location.search);
      const codeParam = urlParams.get('code');
      if (codeParam && validateCode(codeParam)) {
        console.log('Detected code in URL, triggering autoConnect');
        autoConnect(codeParam);
      } else {
        console.log('No valid code in URL, showing initial container');
        initialContainer.classList.remove('hidden');
        usernameContainer.classList.add('hidden');
        connectContainer.classList.add('hidden');
        chatContainer.classList.add('hidden');
        codeDisplayElement.classList.add('hidden');
        copyCodeButton.classList.add('hidden');
        statusElement.textContent = 'Start a new chat or connect to an existing one';
      }
      // Initialize relay socket as backup
      initRelaySocket();
    };

    socket.onerror = (error) => {
      console.error('WebSocket error:', error);
      showStatusMessage('Connection error, switching to server relay...');
      stopKeepAlive();
      connectionTimeouts.forEach((timeout) => clearTimeout(timeout));
      isRelayMode = true;
      if (!relaySocket || relaySocket.readyState !== WebSocket.OPEN) {
        initRelaySocket();
      }
    };

    socket.onclose = () => {
      console.error('WebSocket closed, attempting reconnect');
      stopKeepAlive();
      showStatusMessage('Lost connection, switching to server relay...');
      const delay = Math.min(30000, 5000 * Math.pow(2, reconnectAttempts));
      reconnectAttempts++;
      setTimeout(() => {
        const newSocket = new WebSocket('wss://signaling-server-zc6m.onrender.com');
        newSocket.onopen = () => {
          console.log('Reconnected, sending connect');
          newSocket.send(JSON.stringify({ type: 'connect', clientId }));
          startKeepAlive();
          if (code && username && validateCode(code) && validateUsername(username)) {
            console.log('Rejoining with code:', code);
            newSocket.send(JSON.stringify({ type: 'join', code, clientId, username }));
          }
        };
        newSocket.onerror = socket.onerror;
        newSocket.onclose = socket.onclose;
        newSocket.onmessage = socket.onmessage;
        Object.defineProperty(window, 'socket', { value: newSocket, writable: true });
      }, delay);
      isRelayMode = true;
      if (!relaySocket || relaySocket.readyState !== WebSocket.OPEN) {
        initRelaySocket();
      }
    };

    socket.onmessage = (event) => {
      console.log('Received WebSocket message:', event.data);
      try {
        const message = JSON.parse(event.data);
        console.log('Parsed message:', message);
        if (message.type === 'pong') {
          console.log('Received signaling keepalive pong');
          return;
        }
        if (message.type === 'error') {
          showStatusMessage(message.message);
          console.error('Server error:', message.message);
          if (message.message.includes('Chat is full') || message.message.includes('Username already taken') || message.message.includes('Initiator offline')) {
            isRelayMode = true;
            if (!relaySocket || relaySocket.readyState !== WebSocket.OPEN) {
              initRelaySocket();
            } else if (relaySocket.readyState === WebSocket.OPEN) {
              relaySocket.send(JSON.stringify({ type: 'join', code, clientId, username }));
            }
            resetToInitialState();
          }
          return;
        }
        if (message.type === 'init') {
          clientId = message.clientId;
          maxClients = Math.min(message.maxClients, 10);
          isInitiator = message.isInitiator;
          totalClients = 1;
          console.log(`Initialized client ${clientId}, username: ${username}, maxClients: ${maxClients}, isInitiator: ${isInitiator}`);
          usernames.set(clientId, username);
          initializeMaxClientsUI();
          updateMaxClientsUI();
        }
        if (message.type === 'initiator-changed') {
          console.log(`Initiator changed to ${message.newInitiator} for code: ${code}`);
          isInitiator = message.newInitiator === clientId;
          initializeMaxClientsUI();
          updateMaxClientsUI();
          if (!isInitiator && dataChannels.size === 0) {
            console.log('Initiator changed and no P2P connections, switching to relay mode');
            isRelayMode = true;
            if (!relaySocket || relaySocket.readyState !== WebSocket.OPEN) {
              initRelaySocket();
            } else {
              relaySocket.send(JSON.stringify({ type: 'join', code, clientId, username }));
            }
          }
        }
        if (message.type === 'join-notify' && message.code === code) {
          totalClients = message.totalClients;
          console.log(`Join-notify received for code: ${code}, client: ${message.clientId}, total: ${totalClients}, username: ${message.username}`);
          if (message.username) {
            usernames.set(message.clientId, message.username);
          }
          updateMaxClientsUI();
          if (isInitiator && message.clientId !== clientId && !peerConnections.has(message.clientId)) {
            console.log(`Initiating peer connection with client ${message.clientId}`);
            startPeerConnection(message.clientId, true);
          }
        }
        if (message.type === 'client-disconnected') {
          totalClients = message.totalClients;
          console.log(`Client ${message.clientId} disconnected from code: ${code}, total: ${totalClients}`);
          usernames.delete(message.clientId);
          cleanupPeerConnection(message.clientId);
          updateMaxClientsUI();
          if (totalClients <= 1) {
            inputContainer.classList.add('hidden');
            messages.classList.add('waiting');
          }
          if (!isInitiator && dataChannels.size === 0) {
            console.log('No P2P connections after disconnect, switching to relay mode');
            isRelayMode = true;
            if (!relaySocket || relaySocket.readyState !== WebSocket.OPEN) {
              initRelaySocket();
            } else {
              relaySocket.send(JSON.stringify({ type: 'join', code, clientId, username }));
            }
          }
        }
        if (message.type === 'max-clients') {
          maxClients = Math.min(message.maxClients, 10);
          console.log(`Max clients updated to ${maxClients} for code: ${code}`);
          updateMaxClientsUI();
        }
        if (message.type === 'offer' && message.clientId !== clientId) {
          console.log(`Received offer from ${message.clientId} for code: ${code}`);
          handleOffer(message.offer, message.clientId);
        }
        if (message.type === 'answer' && message.clientId !== clientId) {
          console.log(`Received answer from ${message.clientId} for code: ${code}`);
          handleAnswer(message.answer, message.clientId);
        }
        if (message.type === 'candidate' && message.clientId !== clientId) {
          console.log(`Received ICE candidate from ${message.clientId} for code: ${code}`);
          handleCandidate(message.candidate, message.clientId);
        }
        if (message.type === 'random-code') {
          console.log(`Received random code: ${message.code}`);
          if (code !== message.code) {
            resetToInitialState();
            code = message.code;
            codeDisplayElement.textContent = `Using code: ${code}`;
            codeDisplayElement.classList.remove('hidden');
            copyCodeButton.classList.remove('hidden');
            chatContainer.classList.remove('hidden');
            messages.classList.add('waiting');
            statusElement.textContent = 'Waiting for connection...';
            if (socket.readyState === WebSocket.OPEN) {
              socket.send(JSON.stringify({ type: 'join', code, clientId, username }));
            }
            if (relaySocket && relaySocket.readyState === WebSocket.OPEN) {
              relaySocket.send(JSON.stringify({ type: 'join', code, clientId, username }));
            }
            document.getElementById('messageInput').focus();
          }
        }
      } catch (error) {
        console.error('Error parsing message:', error);
        showStatusMessage('Error receiving message, switching to server relay...');
        isRelayMode = true;
        if (!relaySocket || relaySocket.readyState !== WebSocket.OPEN) {
          initRelaySocket();
        }
      }
    };

    function initializeMaxClientsUI() {
      console.log('initializeMaxClientsUI called, isInitiator:', isInitiator);
      const maxClientsRadios = document.getElementById('maxClientsRadios');
      if (!maxClientsRadios) {
        console.error('maxClientsRadios element not found');
        showStatusMessage('Error: UI initialization failed.');
        return;
      }
      maxClientsRadios.innerHTML = '';
      if (isInitiator) {
        console.log('Creating buttons for maxClients, current maxClients:', maxClients);
        maxClientsContainer.classList.remove('hidden');
        for (let n = 2; n <= 10; n++) {
          const button = document.createElement('button');
          button.textContent = n;
          button.setAttribute('aria-label', `Set maximum users to ${n}`);
          button.className = n === maxClients ? 'active' : '';
          button.disabled = !isInitiator;
          button.addEventListener('click', () => {
            if (isInitiator) {
              console.log(`Button clicked for maxClients: ${n}`);
              setMaxClients(n);
              document.querySelectorAll('#maxClientsRadios button').forEach(btn => btn.classList.remove('active'));
              button.classList.add('active');
            }
          });
          maxClientsRadios.appendChild(button);
        }
        console.log('Buttons appended to maxClientsRadios');
      } else {
        console.log('Hiding maxClientsContainer for non-initiator');
        maxClientsContainer.classList.add('hidden');
      }
    }

    function updateMaxClientsUI() {
      console.log('updateMaxClientsUI called, maxClients:', maxClients, 'isInitiator:', isInitiator);
      statusElement.textContent = isConnected ? `Connected (${totalClients}/${maxClients} connections${isRelayMode ? ' via server' : ''})` : 'Waiting for connection...';
      const buttons = document.querySelectorAll('#maxClientsRadios button');
      console.log('Found buttons:', buttons.length);
      buttons.forEach(button => {
        const value = parseInt(button.textContent);
        button.classList.toggle('active', value === maxClients);
        button.disabled = !isInitiator;
      });
      maxClientsContainer.classList.toggle('hidden', !isInitiator);
      if (!isConnected) {
        messages.classList.add('waiting');
      } else {
        messages.classList.remove('waiting');
      }
    }

    function setMaxClients(n) {
      if (isInitiator && clientId && socket.readyState === WebSocket.OPEN) {
        maxClients = Math.min(n, 10);
        console.log(`setMaxClients called with n: ${n}, new maxClients: ${maxClients}`);
        socket.send(JSON.stringify({ type: 'set-max-clients', maxClients: maxClients, code, clientId }));
        updateMaxClientsUI();
      } else {
        console.warn('setMaxClients failed: not initiator or socket not open');
      }
    }

    function startPeerConnection(targetId, isOfferer) {
      console.log(`Starting peer connection with ${targetId} for code: ${code}, offerer: ${isOfferer}`);
      if (peerConnections.has(targetId)) {
        console.log(`Cleaning up existing connection with ${targetId}`);
        cleanupPeerConnection(targetId);
      }
      const peerConnection = new RTCPeerConnection({
        iceServers: [
          { urls: "stun:stun.relay.metered.ca:80" },
          {
            urls: "turn:global.relay.metered.ca:80",
            username: "8008f3d422fbe49ca4157b23",
            credential: "E7rLb3LegFMDdjem"
          },
          {
            urls: "turn:global.relay.metered.ca:80?transport=tcp",
            username: "8008f3d422fbe49ca4157b23",
            credential: "E7rLb3LegFMDdjem"
          },
          {
            urls: "turn:global.relay.metered.ca:443",
            username: "8008f3d422fbe49ca4157b23",
            credential: "E7rLb3LegFMDdjem"
          },
          {
            urls: "turns:global.relay.metered.ca:443?transport=tcp",
            username: "8008f3d422fbe49ca4157b23",
            credential: "E7rLb3LegFMDdjem"
          }
        ],
        iceTransportPolicy: 'all'
      });
      peerConnections.set(targetId, peerConnection);
      candidatesQueues.set(targetId, []);

      let dataChannel;
      if (isOfferer) {
        dataChannel = peerConnection.createDataChannel('chat');
        console.log(`Created data channel for ${targetId}`);
        setupDataChannel(dataChannel, targetId);
        dataChannels.set(targetId, dataChannel);
      }

      peerConnection.onicecandidate = (event) => {
        if (event.candidate) {
          console.log(`Sending ICE candidate to ${targetId} for code: ${code}`);
          if (socket.readyState === WebSocket.OPEN) {
            socket.send(JSON.stringify({ type: 'candidate', candidate: event.candidate, code, targetId, clientId }));
          }
        }
      };

      peerConnection.onicecandidateerror = (event) => {
        console.error(`ICE candidate error for ${targetId}: ${event.errorText}, code=${event.errorCode}`);
        if (event.errorCode !== 701) {
          const retryCount = retryCounts.get(targetId) || 0;
          if (retryCount < maxRetries) {
            retryCounts.set(targetId, retryCount + 1);
            console.log(`Retrying connection with ${targetId}, attempt ${retryCount + 1}`);
            startPeerConnection(targetId, isOfferer);
          }
        } else {
          console.log(`Ignoring ICE 701 error for ${targetId}, continuing connection`);
        }
      };

      peerConnection.onicegatheringstatechange = () => {
        console.log(`ICE gathering state for ${targetId}: ${peerConnection.iceGatheringState}`);
      };

      peerConnection.onconnectionstatechange = () => {
        console.log(`Connection state for ${targetId}: ${peerConnection.connectionState}`);
        if (peerConnection.connectionState === 'disconnected' || peerConnection.connectionState === 'failed') {
          console.log(`Connection failed with ${targetId}`);
          showStatusMessage('Peer connection failed, attempting to reconnect...');
          cleanupPeerConnection(targetId);
          const retryCount = retryCounts.get(targetId) || 0;
          if (retryCount < maxRetries) {
            retryCounts.set(targetId, retryCount + 1);
            console.log(`Retrying connection attempt ${retryCount + 1} with ${targetId}`);
            startPeerConnection(targetId, isOfferer);
          }
        } else if (peerConnection.connectionState === 'connected') {
          console.log(`WebRTC connection established with ${targetId} for code: ${code}`);
          isConnected = true;
          isRelayMode = false;
          retryCounts.delete(targetId);
          clearTimeout(connectionTimeouts.get(targetId));
          updateMaxClientsUI();
        }
        checkConnectionStatus();
      };

      peerConnection.ondatachannel = (event) => {
        console.log(`Received data channel from ${targetId}`);
        if (dataChannels.has(targetId)) {
          console.log(`Closing existing data channel for ${targetId}`);
          const existingChannel = dataChannels.get(targetId);
          existingChannel.close();
        }
        dataChannel = event.channel;
        setupDataChannel(dataChannel, targetId);
        dataChannels.set(targetId, dataChannel);
      };

      if (isOfferer) {
        peerConnection.createOffer().then(offer => {
          return peerConnection.setLocalDescription(offer);
        }).then(() => {
          console.log(`Sending offer to ${targetId} for code: ${code}`);
          if (socket.readyState === WebSocket.OPEN) {
            socket.send(JSON.stringify({ type: 'offer', offer: peerConnection.localDescription, code, targetId, clientId }));
          }
        }).catch(error => {
          console.error(`Error creating offer for ${targetId}:`, error);
          showStatusMessage('Failed to establish peer connection.');
        });
      }

      const timeout = setTimeout(() => {
        if (!dataChannels.get(targetId) || dataChannels.get(targetId).readyState !== 'open') {
          console.log(`Connection timed out with ${targetId}`);
          cleanupPeerConnection(targetId);
          const retryCount = retryCounts.get(targetId) || 0;
          if (retryCount < maxRetries) {
            retryCounts.set(targetId, retryCount + 1);
            console.log(`Retrying connection attempt ${retryCount + 1} with ${targetId}`);
            startPeerConnection(targetId, isOfferer);
          }
        }
      }, 30000);
      connectionTimeouts.set(targetId, timeout);
    }

    function setupDataChannel(dataChannel, targetId) {
      console.log('setupDataChannel initialized for targetId:', targetId);
      dataChannel.onopen = () => {
        console.log(`Data channel opened with ${targetId} for code: ${code}, state: ${dataChannel.readyState}`);
        isConnected = true;
        isRelayMode = false;
        initialContainer.classList.add('hidden');
        usernameContainer.classList.add('hidden');
        connectContainer.classList.add('hidden');
        chatContainer.classList.remove('hidden');
        newSessionButton.classList.remove('hidden');
        inputContainer.classList.remove('hidden');
        messages.classList.remove('waiting');
        clearTimeout(connectionTimeouts.get(targetId));
        retryCounts.delete(targetId);
        updateMaxClientsUI();
        document.getElementById('messageInput').focus();
      };

      dataChannel.onmessage = (event) => {
        const now = performance.now();
        const rateLimit = messageRateLimits.get(targetId) || { count: 0, startTime: now };
        if (now - rateLimit.startTime >= 1000) {
          rateLimit.count = 0;
          rateLimit.startTime = now;
        }
        rateLimit.count += 1;
        messageRateLimits.set(targetId, rateLimit);
        if (rateLimit.count > 10) {
          console.warn(`Rate limit exceeded for ${targetId}: ${rateLimit.count} messages in 1s`);
          showStatusMessage('Message rate limit reached, please slow down.');
          return;
        }

        let data;
        try {
          data = JSON.parse(event.data);
        } catch (e) {
          console.error(`Invalid message from ${targetId}:`, e);
          showStatusMessage('Invalid message received.');
          return;
        }
        if (!data.messageId || !data.username || (!data.content && data.type !== 'image') || (data.type === 'image' && !data.data)) {
          console.log(`Invalid message format from ${targetId}:`, data);
          return;
        }
        if (processedMessageIds.has(data.messageId)) {
          console.log(`Duplicate message ${data.messageId} from ${targetId}`);
          return;
        }
        processedMessageIds.add(data.messageId);
        const senderUsername = usernames.get(targetId) || data.username;
        const messages = document.getElementById('messages');
        const isSelf = senderUsername === username;
        const messageDiv = document.createElement('div');
        messageDiv.className = `message-bubble ${isSelf ? 'self' : 'other'}`;
        if (data.type === 'image') {
          messageDiv.textContent = `${senderUsername}: `;
          const img = document.createElement('img');
          img.src = data.data;
          img.style.maxWidth = '100%';
          img.style.borderRadius = '0.5rem';
          img.style.cursor = 'pointer';
          img.setAttribute('alt', 'Received image');
          img.addEventListener('click', () => {
            let modal = document.getElementById('imageModal');
            if (!modal) {
              modal = document.createElement('div');
              modal.id = 'imageModal';
              modal.className = 'modal';
              modal.setAttribute('role', 'dialog');
              modal.setAttribute('aria-label', 'Image viewer');
              modal.setAttribute('tabindex', '-1');
              document.body.appendChild(modal);
            }
            modal.innerHTML = '';
            const modalImg = document.createElement('img');
            modalImg.src = data.data;
            modalImg.setAttribute('alt', 'Enlarged image');
            modal.appendChild(modalImg);
            modal.classList.add('active');
            modal.focus();
            modal.addEventListener('click', () => {
              modal.classList.remove('active');
              document.getElementById('messageInput').focus();
            });
            modal.addEventListener('keydown', (event) => {
              if (event.key === 'Escape') {
                modal.classList.remove('active');
                document.getElementById('messageInput').focus();
              }
            });
          });
          messageDiv.appendChild(img);
        } else {
          messageDiv.textContent = `${senderUsername}: ${sanitizeMessage(data.content)}`;
        }
        messages.prepend(messageDiv);
        messages.scrollTop = messages.scrollHeight;
        if (isInitiator) {
          dataChannels.forEach((dc, id) => {
            if (id !== targetId && dc.readyState === 'open') {
              dc.send(JSON.stringify(data));
            }
          });
        }
      };

      dataChannel.onerror = (error) => {
        console.error(`Data channel error with ${targetId}:`, error);
        showStatusMessage('Error in peer connection.');
      };

      dataChannel.onclose = () => {
        console.log(`Data channel closed with ${targetId}`);
        showStatusMessage('Peer disconnected.');
        cleanupPeerConnection(targetId);
        messageRateLimits.delete(targetId);
        imageRateLimits.delete(targetId);
        if (dataChannels.size === 0) {
          inputContainer.classList.add('hidden');
          messages.classList.add('waiting');
        }
        checkConnectionStatus();
      };
    }

    async function handleOffer(offer, targetId) {
      console.log(`Handling offer from ${targetId} for code: ${code}`);
      if (offer.type !== 'offer') {
        console.error(`Invalid offer type from ${targetId}:`, offer.type);
        return;
      }
      if (!peerConnections.has(targetId)) {
        console.log(`No existing peer connection for ${targetId}, starting new one`);
        startPeerConnection(targetId, false);
      }
      const peerConnection = peerConnections.get(targetId);
      try {
        await peerConnection.setRemoteDescription(new RTCSessionDescription(offer));
        const answer = await peerConnection.createAnswer();
        await peerConnection.setLocalDescription(answer);
        if (socket.readyState === WebSocket.OPEN) {
          socket.send(JSON.stringify({ type: 'answer', answer: peerConnection.localDescription, code, targetId, clientId }));
        }
        const queue = candidatesQueues.get(targetId) || [];
        queue.forEach(candidate => {
          handleCandidate(candidate, targetId);
        });
        candidatesQueues.set(targetId, []);
      } catch (error) {
        console.error(`Error handling offer from ${targetId}:`, error);
        showStatusMessage('Failed to connect to peer.');
      }
    }

    async function handleAnswer(answer, targetId) {
      console.log(`Handling answer from ${targetId} for code: ${code}`);
      if (!peerConnections.has(targetId)) {
        console.log(`No peer connection for ${targetId}, starting new one and queuing answer`);
        startPeerConnection(targetId, false);
        candidatesQueues.get(targetId).push({ type: 'answer', answer });
        return;
      }
      const peerConnection = peerConnections.get(targetId);
      if (answer.type !== 'answer') {
        console.error(`Invalid answer type from ${targetId}:`, answer.type);
        return;
      }
      if (peerConnection.signalingState !== 'have-local-offer') {
        console.log(`Queuing answer from ${targetId}`);
        candidatesQueues.get(targetId).push({ type: 'answer', answer });
        return;
      }
      try {
        await peerConnection.setRemoteDescription(new RTCSessionDescription(answer));
        const queue = candidatesQueues.get(targetId) || [];
        queue.forEach(item => {
          if (item.type === 'answer') {
            peerConnection.setRemoteDescription(new RTCSessionDescription(item.answer)).catch(error => {
              console.error(`Error applying queued answer from ${targetId}:`, error);
              showStatusMessage('Error processing peer response.');
            });
          } else if (item.type === 'candidate') {
            handleCandidate(item.candidate, targetId);
          }
        });
        candidatesQueues.set(targetId, []);
      } catch (error) {
        console.error(`Error handling answer from ${targetId}:`, error);
        showStatusMessage('Error connecting to peer.');
      }
    }

    function handleCandidate(candidate, targetId) {
      console.log(`Handling ICE candidate from ${targetId} for code: ${code}`);
      const peerConnection = peerConnections.get(targetId);
      if (peerConnection && peerConnection.remoteDescription) {
        peerConnection.addIceCandidate(new RTCIceCandidate(candidate)).catch(error => {
          console.error(`Error adding ICE candidate from ${targetId}:`, error);
          showStatusMessage('Error establishing peer connection.');
        });
      } else {
        const queue = candidatesQueues.get(targetId) || [];
        queue.push({ type: 'candidate', candidate });
        candidatesQueues.set(targetId, queue);
      }
    }

    function cleanupPeerConnection(targetId) {
      const peerConnection = peerConnections.get(targetId);
      const dataChannel = dataChannels.get(targetId);
      if (dataChannel && dataChannel.readyState === 'open') {
        console.log(`Skipping cleanup for ${targetId}: data channel is open`);
        return;
      }
      if (peerConnection) {
        peerConnection.close();
        peerConnections.delete(targetId);
      }
      if (dataChannel) {
        dataChannel.close();
        dataChannels.delete(targetId);
      }
      candidatesQueues.delete(targetId);
      clearTimeout(connectionTimeouts.get(targetId));
      connectionTimeouts.delete(targetId);
      retryCounts.delete(targetId);
      messageRateLimits.delete(targetId);
      imageRateLimits.delete(targetId);
      isConnected = dataChannels.size > 0;
      updateMaxClientsUI();
      if (!isConnected) {
        inputContainer.classList.add('hidden');
        messages.classList.add('waiting');
      }
      checkConnectionStatus();
    }

    function sendMessage(content) {
      if (content && (dataChannels.size > 0 || (isRelayMode && relaySocket && relaySocket.readyState === WebSocket.OPEN)) && username) {
        const messageId = generateMessageId();
        const sanitizedContent = sanitizeMessage(content);
        const message = { messageId, content: sanitizedContent, username, code };
        const jsonString = JSON.stringify(message);
        if (isRelayMode) {
          if (relaySocket && relaySocket.readyState === WebSocket.OPEN) {
            relaySocket.send(jsonString);
          } else {
            showStatusMessage('Error: Not connected to server.');
            document.getElementById('messageInput').focus();
            return;
          }
        } else {
          dataChannels.forEach((dataChannel, targetId) => {
            if (dataChannel.readyState === 'open') {
              dataChannel.send(jsonString);
            }
          });
        }
        const messages = document.getElementById('messages');
        const messageDiv = document.createElement('div');
        messageDiv.className = 'message-bubble self';
        messageDiv.textContent = `${username}: ${sanitizedContent}`;
        messages.prepend(messageDiv);
        messages.scrollTop = messages.scrollHeight;
        const messageInput = document.getElementById('messageInput');
        messageInput.value = '';
        messageInput.style.height = '2.5rem';
        processedMessageIds.add(messageId);
        messageInput.focus();
      } else {
        showStatusMessage('Error: No connections or username not set.');
        document.getElementById('messageInput').focus();
      }
    }

    document.getElementById('startChatToggleButton').onclick = () => {
      console.log('Start chat toggle clicked');
      initialContainer.classList.add('hidden');
      usernameContainer.classList.remove('hidden');
      connectContainer.classList.add('hidden');
      chatContainer.classList.add('hidden');
      codeDisplayElement.classList.add('hidden');
      copyCodeButton.classList.add('hidden');
      statusElement.textContent = 'Enter a username to start a chat';
      document.getElementById('usernameInput').value = username || '';
      document.getElementById('usernameInput').focus();
    };

    document.getElementById('connectToggleButton').onclick = () => {
      console.log('Connect toggle clicked');
      initialContainer.classList.add('hidden');
      usernameContainer.classList.add('hidden');
      connectContainer.classList.remove('hidden');
      chatContainer.classList.add('hidden');
      codeDisplayElement.classList.add('hidden');
      copyCodeButton.classList.add('hidden');
      statusElement.textContent = 'Enter a username and code to join a chat';
      document.getElementById('usernameConnectInput').value = username || '';
      document.getElementById('usernameConnectInput').focus();
    };

    document.getElementById('joinWithUsernameButton').onclick = () => {
      const usernameInput = document.getElementById('usernameInput').value.trim();
      if (!validateUsername(usernameInput)) {
        showStatusMessage('Invalid username: 1-16 alphanumeric characters.');
        document.getElementById('usernameInput').focus();
        return;
      }
      username = usernameInput;
      localStorage.setItem('username', username);
      console.log('Username set in localStorage:', username);
      code = generateCode();
      codeDisplayElement.textContent = `Your code: ${code}`;
      codeDisplayElement.classList.remove('hidden');
      copyCodeButton.classList.remove('hidden');
      usernameContainer.classList.add('hidden');
      connectContainer.classList.add('hidden');
      initialContainer.classList.add('hidden');
      chatContainer.classList.remove('hidden');
      messages.classList.add('waiting');
      statusElement.textContent = 'Waiting for connection...';
      if (socket.readyState === WebSocket.OPEN) {
        console.log('Sending join message for new chat');
        socket.send(JSON.stringify({ type: 'join', code, clientId, username }));
      } else {
        socket.addEventListener('open', () => {
          console.log('WebSocket opened, sending join for new chat');
          socket.send(JSON.stringify({ type: 'join', code, clientId, username }));
        }, { once: true });
      }
      if (relaySocket && relaySocket.readyState === WebSocket.OPEN) {
        console.log('Sending join to relay server');
        relaySocket.send(JSON.stringify({ type: 'join', code, clientId, username }));
      } else {
        initRelaySocket();
      }
      document.getElementById('messageInput').focus();
    };

    document.getElementById('connectButton').onclick = () => {
      const usernameInput = document.getElementById('usernameConnectInput').value.trim();
      const inputCode = document.getElementById('codeInput').value.trim();
      if (!validateUsername(usernameInput)) {
        showStatusMessage('Invalid username: 1-16 alphanumeric characters.');
        document.getElementById('usernameConnectInput').focus();
        return;
      }
      if (!validateCode(inputCode)) {
        showStatusMessage('Invalid code format: xxxx-xxxx-xxxx-xxxx.');
        document.getElementById('codeInput').focus();
        return;
      }
      username = usernameInput;
      localStorage.setItem('username', username);
      console.log('Username set in localStorage:', username);
      code = inputCode;
      codeDisplayElement.textContent = `Using code: ${code}`;
      codeDisplayElement.classList.remove('hidden');
      copyCodeButton.classList.remove('hidden');
      initialContainer.classList.add('hidden');
      usernameContainer.classList.add('hidden');
      connectContainer.classList.add('hidden');
      chatContainer.classList.remove('hidden');
      messages.classList.add('waiting');
      statusElement.textContent = 'Waiting for connection...';
      if (socket.readyState === WebSocket.OPEN) {
        console.log('Sending join message for existing chat');
        socket.send(JSON.stringify({ type: 'join', code, clientId, username }));
      } else {
        socket.addEventListener('open', () => {
          console.log('WebSocket opened, sending join for existing chat');
          socket.send(JSON.stringify({ type: 'join', code, clientId, username }));
        }, { once: true });
      }
      if (relaySocket && relaySocket.readyState === WebSocket.OPEN) {
        console.log('Sending join to relay server');
        relaySocket.send(JSON.stringify({ type: 'join', code, clientId, username }));
      } else {
        initRelaySocket();
      }
      document.getElementById('messageInput').focus();
    };

    document.getElementById('backButton').onclick = () => {
      console.log('Back button clicked');
      resetToInitialState();
    };

    document.getElementById('backButtonConnect').onclick = () => {
      console.log('Back button (connect) clicked');
      resetToInitialState();
    };

    document.getElementById('newSessionButton').onclick = () => {
      console.log('New session button clicked');
      resetToInitialState();
    };

    document.getElementById('copyCodeButton').onclick = () => {
      console.log('Copy code button clicked');
      navigator.clipboard.writeText(code).then(() => {
        showStatusMessage('Code copied to clipboard!');
      }).catch(() => {
        showStatusMessage('Failed to copy code.');
      });
    };

    document.getElementById('button1').onclick = () => {
      console.log('Send code button clicked');
      if (socket.readyState === WebSocket.OPEN && !codeSentToRandom) {
        socket.send(JSON.stringify({ type: 'send-code', code,
                                            codeSentToRandom = true;
        button2.disabled = true;
        showStatusMessage('Code sent to random chat board!');
      } else if (codeSentToRandom) {
        showStatusMessage('Code already sent to random chat board.');
      } else {
        showStatusMessage('Error: Cannot send code, not connected.');
      }
    };

    document.getElementById('button2').onclick = () => {
      console.log('Random chat button clicked');
      if (socket.readyState === WebSocket.OPEN && !codeSentToRandom) {
        socket.send(JSON.stringify({ type: 'get-random-code', clientId }));
        showStatusMessage('Joining a random chat...');
      } else if (codeSentToRandom) {
        showStatusMessage('Already sent code to random chat board.');
      } else {
        showStatusMessage('Error: Cannot join random chat, not connected.');
      }
    };

    document.getElementById('sendButton').onclick = () => {
      console.log('Send button clicked');
      const messageInput = document.getElementById('messageInput');
      const content = messageInput.value.trim();
      if (content) {
        sendMessage(content);
      } else {
        showStatusMessage('Please enter a message.');
        messageInput.focus();
      }
    };

    document.getElementById('messageInput').addEventListener('keydown', (event) => {
      if (event.key === 'Enter' && !event.shiftKey) {
        event.preventDefault();
        const content = event.target.value.trim();
        if (content) {
          sendMessage(content);
        } else {
          showStatusMessage('Please enter a message.');
          event.target.focus();
        }
      }
    });

    document.getElementById('messageInput').addEventListener('input', (event) => {
      const textarea = event.target;
      textarea.style.height = '2.5rem';
      textarea.style.height = `${Math.min(textarea.scrollHeight, 200)}px`;
    });

    document.getElementById('imageButton').onclick = () => {
      console.log('Image button clicked');
      document.getElementById('imageInput').click();
    };

    document.getElementById('imageInput').addEventListener('change', (event) => {
      console.log('Image input changed');
      const file = event.target.files[0];
      if (file) {
        sendImage(file);
        event.target.value = '';
      }
    });

    // Auto-connect from URL
    function autoConnect(codeParam) {
      console.log('autoConnect triggered with code:', codeParam);
      initialContainer.classList.add('hidden');
      usernameContainer.classList.remove('hidden');
      connectContainer.classList.add('hidden');
      chatContainer.classList.add('hidden');
      codeDisplayElement.classList.add('hidden');
      copyCodeButton.classList.add('hidden');
      statusElement.textContent = 'Enter a username to join the chat';
      document.getElementById('usernameInput').value = username || '';
      document.getElementById('usernameInput').focus();
      document.getElementById('joinWithUsernameButton').onclick = () => {
        const usernameInput = document.getElementById('usernameInput').value.trim();
        if (!validateUsername(usernameInput)) {
          showStatusMessage('Invalid username: 1-16 alphanumeric characters.');
          document.getElementById('usernameInput').focus();
          return;
        }
        username = usernameInput;
        localStorage.setItem('username', username);
        console.log('Username set in localStorage:', username);
        code = codeParam;
        codeDisplayElement.textContent = `Using code: ${code}`;
        codeDisplayElement.classList.remove('hidden');
        copyCodeButton.classList.remove('hidden');
        usernameContainer.classList.add('hidden');
        connectContainer.classList.add('hidden');
        initialContainer.classList.add('hidden');
        chatContainer.classList.remove('hidden');
        messages.classList.add('waiting');
        statusElement.textContent = 'Waiting for connection...';
        if (socket.readyState === WebSocket.OPEN) {
          console.log('Sending join message for auto-connect');
          socket.send(JSON.stringify({ type: 'join', code, clientId, username }));
        } else {
          socket.addEventListener('open', () => {
            console.log('WebSocket opened, sending join for auto-connect');
            socket.send(JSON.stringify({ type: 'join', code, clientId, username }));
          }, { once: true });
        }
        if (relaySocket && relaySocket.readyState === WebSocket.OPEN) {
          console.log('Sending join to relay server for auto-connect');
          relaySocket.send(JSON.stringify({ type: 'join', code, clientId, username }));
        } else {
          initRelaySocket();
        }
        document.getElementById('messageInput').focus();
      };
    }

    // Handle page unload
    window.addEventListener('beforeunload', () => {
      console.log('Window unloading, sending leave message');
      if (socket.readyState === WebSocket.OPEN) {
        socket.send(JSON.stringify({ type: 'leave', code, clientId }));
      }
      if (relaySocket && relaySocket.readyState === WebSocket.OPEN) {
        relaySocket.send(JSON.stringify({ type: 'leave', code, clientId }));
      }
      peerConnections.forEach((pc) => pc.close());
      dataChannels.forEach((dc) => dc.close());
      stopKeepAlive();
      stopRelayKeepAlive();
    });

  </script>
</body>
</html>
    
