<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Anonymous Chat</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css">
  <link rel="icon" type="image/png" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAACklEQVR4nGMAAQAABQABDQottroo"/>
</head>
<body class="bg-black min-h-screen flex items-center justify-center">
  <div class="flex w-full max-w-lg">
    <div class="bg-white p-8 rounded-lg shadow-lg flex-grow">
      <h1 class="text-2xl font-bold mb-6 text-center text-gray-800">Anonymous Chat</h1>
      <div id="status" class="text-center mb-4 text-gray-600">Start a new chat or connect to an existing one</div>
      <div id="initialContainer">
        <button id="startChatToggleButton" class="bg-blue-500 text-white px-4 py-2 rounded w-full mb-2 hover:bg-blue-600">Start Chat</button>
        <button id="connectToggleButton" class="bg-green-500 text-white px-4 py-2 rounded w-full hover:bg-green-600">Connect to Chat</button>
      </div>
      <div id="usernameContainer" class="hidden">
        <input id="usernameInput" type="text" class="border border-gray-300 p-2 w-full mb-2 rounded" placeholder="Enter your username (1-16 chars)">
        <button id="startChatButton" class="bg-blue-500 text-white px-4 py-2 rounded w-full hover:bg-blue-600">Start Chat</button>
        <button id="backButton" class="bg-gray-500 text-white px-4 py-2 rounded w-full mt-2 hover:bg-gray-600">Back</button>
      </div>
      <div id="codeDisplay" class="text-center mb-4 font-mono text-lg text-gray-800 hidden"></div>
      <div id="chatContainer" class="hidden">
        <div id="messages" class="border border-gray-300 p-4 h-64 overflow-y-auto mb-4 rounded bg-white"></div>
        <input id="messageInput" type="text" class="border border-gray-300 p-2 w-full mb-2 rounded" placeholder="Type a message...">
        <button id="sendButton" class="bg-blue-500 text-white px-4 py-2 rounded w-full hover:bg-blue-600">Send</button>
      </div>
      <div id="connectContainer" class="hidden">
        <input id="usernameConnectInput" type="text" class="border border-gray-300 p-2 w-full mb-2 rounded" placeholder="Enter your username (1-16 chars)">
        <input id="codeInput" type="text" class="border border-gray-300 p-2 w-full mb-2 rounded" placeholder="Enter code to connect">
        <button id="connectButton" class="bg-green-500 text-white px-4 py-2 rounded w-full hover:bg-green-600">Connect</button>
        <button id="backButtonConnect" class="bg-gray-500 text-white px-4 py-2 rounded w-full mt-2 hover:bg-gray-600">Back</button>
      </div>
      <button id="newSessionButton" class="bg-red-500 text-white px-4 py-2 rounded w-full mt-4 hidden hover:bg-red-600">New Session</button>
    </div>
    <div id="maxClientsContainer" class="hidden ml-4 flex flex-col justify-center bg-gray-800 p-4 rounded-lg">
      <span class="text-white mb-2 font-bold">Max Users:</span>
      <div id="maxClientsRadios" class="flex flex-col space-y-2"></div>
    </div>
  </div>
  <script>
    function generateCode() {
      const chars = 'abcdefghijklmnopqrstuvwxyz0123456789';
      let result = '';
      for (let i = 0; i < 16; i++) {
        result += chars.charAt(Math.floor(Math.random() * chars.length));
        if (i % 4 === 3 && i < 15) result += '-';
      }
      return result;
    }

    function generateMessageId() {
      return Math.random().toString(36).substr(2, 16);
    }

    function validateUsername(username) {
      const regex = /^[a-zA-Z0-9]{1,16}$/;
      return username && regex.test(username);
    }

    let code = generateCode();
    let clientId = '';
    let isInitiator = false;
    let isConnected = false;
    let maxClients = 2;
    let totalClients = 0;
    let peerConnection = null;
    let dataChannel = null;
    let processedMessageIds = new Set();
    let username = null;
    let usernames = new Map();

    const statusElement = document.getElementById('status');
    const codeDisplayElement = document.getElementById('codeDisplay');
    const initialContainer = document.getElementById('initialContainer');
    const usernameContainer = document.getElementById('usernameContainer');
    const connectContainer = document.getElementById('connectContainer');
    const chatContainer = document.getElementById('chatContainer');
    const newSessionButton = document.getElementById('newSessionButton');
    const maxClientsContainer = document.getElementById('maxClientsContainer');

    const socket = new WebSocket('wss://signaling-server-zc6m.onrender.com');
    console.log('WebSocket created');

    socket.onopen = () => {
      console.log('WebSocket opened, state: ' + socket.readyState);
      statusElement.textContent = 'Start a new chat or connect to an existing one';
    };

    socket.onerror = error => {
      statusElement.textContent = 'WebSocket error. Please try again.';
      console.error('WebSocket error:', error);
    };

    socket.onclose = () => {
      statusElement.textContent = 'WebSocket closed. Please refresh.';
      console.error('WebSocket closed, state: ' + socket.readyState);
      cleanup();
    };

    socket.onmessage = event => {
      try {
        const message = JSON.parse(event.data);
        console.log('Received message:', message);
        if (message.type === 'error') {
          statusElement.textContent = message.message;
          console.error('Server error:', message.message);
          if (message.message.includes('Chat is full') || message.message.includes('Username already taken')) {
            resetUI();
          }
          return;
        }
        if (message.type === 'init') {
          clientId = message.clientId;
          maxClients = message.maxClients;
          isInitiator = message.isInitiator;
          totalClients = 1;
          usernames.set(clientId, username);
          console.log(`Initialized client ${clientId}, isInitiator: ${isInitiator}`);
          initializeMaxClients();
          updateStatus();
        }
        if (message.type === 'join-notify' && message.code === code) {
          totalClients = message.totalClients;
          usernames.set(message.clientId, message.username);
          console.log(`Join: ${message.clientId} (${message.username}), total: ${totalClients}`);
          updateStatus();
          if (isInitiator && message.clientId !== clientId) {
            startPeerConnection(true);
          }
        }
        if (message.type === 'client-disconnected') {
          totalClients = message.totalClients;
          usernames.delete(message.clientId);
          console.log(`Disconnected: ${message.clientId}, total: ${totalClients}`);
          cleanup();
          updateStatus();
        }
        if (message.type === 'max-clients') {
          maxClients = message.maxClients;
          console.log(`Max clients: ${maxClients}`);
          updateStatus();
        }
        if (message.type === 'offer' && message.clientId !== clientId) {
          console.log(`Received offer from ${message.clientId}`);
          handleOffer(message.offer);
        }
        if (message.type === 'answer' && message.clientId !== clientId) {
          console.log(`Received answer from ${message.clientId}`);
          handleAnswer(message.answer);
        }
        if (message.type === 'candidate' && message.clientId !== clientId) {
          console.log(`Received candidate from ${message.clientId}`);
          handleCandidate(message.candidate);
        }
      } catch (error) {
        console.error('Error parsing message:', error, 'Data:', event.data);
      }
    };

    function initializeMaxClients() {
      const maxClientsRadios = document.getElementById('maxClientsRadios');
      maxClientsRadios.innerHTML = '';
      if (isInitiator) {
        maxClientsContainer.classList.remove('hidden');
        for (let n = 2; n <= 10; n++) {
          const label = document.createElement('label');
          label.className = 'text-white flex items-center';
          const input = document.createElement('input');
          input.type = 'radio';
          input.name = 'maxClients';
          input.value = n;
          input.className = 'mr-2';
          input.checked = n === maxClients;
          input.addEventListener('change', () => {
            if (isInitiator) {
              socket.send(JSON.stringify({ type: 'set-max-clients', maxClients: n, code }));
            }
          });
          label.appendChild(input);
          label.appendChild(document.createTextNode(n));
          maxClientsRadios.appendChild(label);
        }
      } else {
        maxClientsContainer.classList.add('hidden');
      }
    }

    function updateStatus() {
      statusElement.textContent = isConnected ? `Connected (${totalClients}/${maxClients} users)` : 'Waiting for connection...';
    }

    function startPeerConnection(isOfferer) {
      cleanup();
      peerConnection = new RTCPeerConnection({
        iceServers: [
          { urls: 'stun:stun.l.google.com:19302' },
          { urls: 'turn:openrelay.metered.ca:80', username: 'openrelay', credential: 'openrelay' }
        ]
      });

      if (isOfferer) {
        dataChannel = peerConnection.createDataChannel('chat');
        setupDataChannel(dataChannel);
      }

      peerConnection.onicecandidate = event => {
        if (event.candidate && socket.readyState === WebSocket.OPEN) {
          socket.send(JSON.stringify({ type: 'candidate', candidate: event.candidate, code }));
        }
      };

      peerConnection.oniceconnectionstatechange = () => {
        console.log(`ICE state: ${peerConnection.iceConnectionState}`);
        if (peerConnection.iceConnectionState === 'failed') {
          statusElement.textContent = 'Connection failed. Please try again.';
          cleanup();
        }
      };

      peerConnection.ondatachannel = event => {
        dataChannel = event.channel;
        setupDataChannel(dataChannel);
      };

      if (isOfferer) {
        peerConnection.createOffer()
          .then(offer => peerConnection.setLocalDescription(offer))
          .then(() => {
            if (socket.readyState === WebSocket.OPEN) {
              socket.send(JSON.stringify({ type: 'offer', offer: peerConnection.localDescription, code }));
            }
          })
          .catch(error => console.error('Error creating offer:', error));
      }
    }

    function setupDataChannel(channel) {
      channel.onopen = () => {
        console.log('Data channel opened');
        isConnected = true;
        initialContainer.classList.add('hidden');
        usernameContainer.classList.add('hidden');
        connectContainer.classList.add('hidden');
        chatContainer.classList.remove('hidden');
        newSessionButton.classList.remove('hidden');
        updateStatus();
      };
      channel.onmessage = event => {
        const data = JSON.parse(event.data);
        if (processedMessageIds.has(data.messageId)) return;
        processedMessageIds.add(data.messageId);
        const sender = usernames.get(data.clientId) || data.username;
        const isSelf = sender === username;
        const messages = document.getElementById('messages');
        messages.innerHTML += `<div class="${isSelf ? 'text-blue-600' : 'text-gray-600'}">${sender}: ${data.content}</div>`;
        messages.scrollTop = messages.scrollHeight;
        if (isInitiator && dataChannel.readyState === 'open') {
          socket.send(JSON.stringify({ type: 'relay', message: data, code }));
        }
      };
      channel.onerror = error => console.error('Data channel error:', error);
      channel.onclose = () => {
        console.log('Data channel closed');
        cleanup();
      };
    }

    function handleOffer(offer) {
      if (!peerConnection) startPeerConnection(false);
      peerConnection.setRemoteDescription(new RTCSessionDescription(offer))
        .then(() => peerConnection.createAnswer())
        .then(answer => peerConnection.setLocalDescription(answer))
        .then(() => {
          if (socket.readyState === WebSocket.OPEN) {
            socket.send(JSON.stringify({ type: 'answer', answer: peerConnection.localDescription, code }));
          }
        })
        .catch(error => console.error('Error handling offer:', error));
    }

    function handleAnswer(answer) {
      if (peerConnection) {
        peerConnection.setRemoteDescription(new RTCSessionDescription(answer))
          .catch(error => console.error('Error handling answer:', error));
      }
    }

    function handleCandidate(candidate) {
      if (peerConnection && peerConnection.remoteDescription) {
        peerConnection.addIceCandidate(new RTCIceCandidate(candidate))
          .catch(error => console.error('Error adding candidate:', error));
      }
    }

    function cleanup() {
      if (peerConnection) {
        peerConnection.close();
        peerConnection = null;
      }
      if (dataChannel) {
        dataChannel.close();
        dataChannel = null;
      }
      isConnected = false;
      updateStatus();
    }

    function resetUI() {
      cleanup();
      initialContainer.classList.remove('hidden');
      usernameContainer.classList.add('hidden');
      connectContainer.classList.add('hidden');
      chatContainer.classList.add('hidden');
      newSessionButton.classList.add('hidden');
      maxClientsContainer.classList.add('hidden');
      codeDisplayElement.classList.add('hidden');
      document.getElementById('messages').innerHTML = '';
    }

    function sendMessage(content) {
      if (content && dataChannel && dataChannel.readyState === 'open' && username) {
        const messageId = generateMessageId();
        const message = { messageId, content, username, clientId };
        dataChannel.send(JSON.stringify(message));
        const messages = document.getElementById('messages');
        messages.innerHTML += `<div class="text-blue-600">${username}: ${content}</div>`;
        messages.scrollTop = messages.scrollHeight;
        document.getElementById('messageInput').value = '';
        processedMessageIds.add(messageId);
      } else {
        statusElement.textContent = 'Error: Not connected or no username.';
      }
    }

    document.getElementById('startChatToggleButton').onclick = () => {
      initialContainer.classList.add('hidden');
      usernameContainer.classList.remove('hidden');
      statusElement.textContent = 'Enter a username to start a chat';
    };

    document.getElementById('connectToggleButton').onclick = () => {
      initialContainer.classList.add('hidden');
      connectContainer.classList.remove('hidden');
      statusElement.textContent = 'Enter a username and code to join a chat';
    };

    document.getElementById('startChatButton').onclick = () => {
      const usernameInput = document.getElementById('usernameInput').value.trim();
      if (!validateUsername(usernameInput)) {
        statusElement.textContent = 'Invalid username: 1-16 alphanumeric characters required.';
        return;
      }
      username = usernameInput;
      codeDisplayElement.textContent = `Your code: ${code}`;
      codeDisplayElement.classList.remove('hidden');
      usernameContainer.classList.add('hidden');
      statusElement.textContent = 'Waiting for connection...';
      if (socket.readyState === WebSocket.OPEN) {
        socket.send(JSON.stringify({ type: 'join', code, username }));
      } else {
        statusElement.textContent = 'WebSocket not connected. Please refresh.';
      }
    };

    document.getElementById('connectButton').onclick = () => {
      const usernameInput = document.getElementById('usernameConnectInput').value.trim();
      const inputCode = document.getElementById('codeInput').value.trim();
      if (!validateUsername(usernameInput)) {
        statusElement.textContent = 'Invalid username: 1-16 alphanumeric characters required.';
        return;
      }
      if (!inputCode) {
        statusElement.textContent = 'Please enter a valid code.';
        return;
      }
      username = usernameInput;
      code = inputCode;
      codeDisplayElement.textContent = `Using code: ${code}`;
      codeDisplayElement.classList.remove('hidden');
      connectContainer.classList.add('hidden');
      statusElement.textContent = 'Connecting...';
      if (socket.readyState === WebSocket.OPEN) {
        socket.send(JSON.stringify({ type: 'join', code, username }));
      } else {
        statusElement.textContent = 'WebSocket not connected. Please refresh.';
      }
    };

    document.getElementById('backButton').onclick = () => {
      usernameContainer.classList.add('hidden');
      initialContainer.classList.remove('hidden');
      statusElement.textContent = 'Start a new chat or connect to an existing one';
    };

    document.getElementById('backButtonConnect').onclick = () => {
      connectContainer.classList.add('hidden');
      initialContainer.classList.remove('hidden');
      statusElement.textContent = 'Start a new chat or connect to an existing one';
    };

    document.getElementById('sendButton').onclick = () => {
      sendMessage(document.getElementById('messageInput').value);
    };

    document.getElementById('messageInput').addEventListener('keydown', event => {
      if (event.key === 'Enter') {
        event.preventDefault();
        sendMessage(event.target.value);
      }
    });

    document.getElementById('newSessionButton').onclick = () => {
      cleanup();
      processedMessageIds.clear();
      usernames.clear();
      username = null;
      isInitiator = false;
      maxClients = 2;
      totalClients = 0;
      code = generateCode();
      clientId = '';
      resetUI();
      if (socket.readyState === WebSocket.OPEN) {
        socket.send(JSON.stringify({ type: 'join' }));
      }
    };

    document.getElementById('usernameInput').addEventListener('keydown', event => {
      if (event.key === 'Enter') {
        event.preventDefault();
        document.getElementById('startChatButton').click();
      }
    });

    document.getElementById('usernameConnectInput').addEventListener('keydown', event => {
      if (event.key === 'Enter') {
        event.preventDefault();
        document.getElementById('codeInput').focus();
      }
    });

    document.getElementById('codeInput').addEventListener('keydown', event => {
      if (event.key === 'Enter') {
        event.preventDefault();
        document.getElementById('connectButton').click();
      }
    });
  </script>
</body>
</html>
