<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Anonymous Chat</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css">
  <link rel="icon" type="image/png" href="https://cdnjs.cloudflare.com/ajax/libs/twemoji/14.0.2/72x72/1f60e.png"/>
</head>
<body class="bg-black min-h-screen flex items-center justify-center">
  <div class="flex w-full max-w-lg">
    <div class="bg-white p-8 rounded-lg shadow-lg flex-grow">
      <h1 class="text-2xl font-bold mb-6 text-center text-gray-800">Anonymous Chat</h1>
      <div id="status" class="text-center mb-4 text-gray-600">Start a new chat or connect to an existing one</div>
      <div id="initialContainer">
        <button id="startChatToggleButton" class="bg-blue-500 text-white px-4 py-2 rounded w-full mb-2 hover:bg-blue-600">Start Chat</button>
        <button id="connectToggleButton" class="bg-green-500 text-white px-4 py-2 rounded w-full hover:bg-green-600">Connect to Chat</button>
      </div>
      <div id="usernameContainer" class="hidden">
        <input id="usernameInput" type="text" class="border border-gray-300 p-2 w-full mb-2 rounded" placeholder="Enter your username (1-16 chars)">
        <button id="startChatButton" class="bg-blue-500 text-white px-4 py-2 rounded w-full hover:bg-blue-600">Start Chat</button>
        <button id="backButton" class="bg-gray-500 text-white px-4 py-2 rounded w-full mt-2 hover:bg-gray-600">Back</button>
      </div>
      <div id="codeDisplay" class="text-center mb-4 font-mono text-lg text-gray-800 hidden"></div>
      <div id="chatContainer" class="hidden">
        <div id="messages" class="border border-gray-300 p-4 h-64 overflow-y-auto mb-4 rounded bg-white"></div>
        <input id="messageInput" type="text" class="border border-gray-300 p-2 w-full mb-2 rounded" placeholder="Type a message...">
        <button id="sendButton" class="bg-blue-500 text-white px-4 py-2 rounded w-full hover:bg-blue-600">Send</button>
      </div>
      <div id="connectContainer" class="hidden">
        <input id="usernameConnectInput" type="text" class="border border-gray-300 p-2 w-full mb-2 rounded" placeholder="Enter your username (1-16 chars)">
        <input id="codeInput" type="text" class="border border-gray-300 p-2 w-full mb-2 rounded" placeholder="Enter code (xxxx-xxxx-xxxx-xxxx)">
        <button id="connectButton" class="bg-green-500 text-white px-4 py-2 rounded w-full hover:bg-green-600">Connect</button>
        <button id="backButtonConnect" class="bg-gray-500 text-white px-4 py-2 rounded w-full mt-2 hover:bg-gray-600">Back</button>
      </div>
      <button id="newSessionButton" class="bg-red-500 text-white px-4 py-2 rounded w-full mt-4 hidden hover:bg-red-600">New Session</button>
      <div class="text-center mt-4">
        <a href="https://github.com/cooptroop1/anonmess/wiki/Troubleshooting" target="_blank" class="text-blue-500 hover:underline">Connection issues? Get help</a>
      </div>
    </div>
    <div id="maxClientsContainer" class="hidden ml-4 flex flex-col justify-center bg-gray-800 p-4 rounded-lg">
      <span class="text-white mb-2 font-bold">Max Users:</span>
      <div id="maxClientsRadios" class="flex flex-col space-y-2"></div>
    </div>
  </div>
  <script>
    function generateCode() {
      const chars = 'abcdefghijklmnopqrstuvwxyz0123456789';
      let result = '';
      for (let i = 0; i < 16; i++) {
        result += chars.charAt(Math.floor(Math.random() * chars.length));
        if (i % 4 === 3 && i < 15) result += '-';
      }
      return result;
    }

    function generateMessageId() {
      return Math.random().toString(36).substr(2, 9);
    }

    function validateUsername(username) {
      const regex = /^[a-zA-Z0-9]{1,16}$/;
      return username && regex.test(username);
    }

    function validateCode(code) {
      const regex = /^[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}$/;
      return code && regex.test(code);
    }

    let code = generateCode();
    let clientId = '';
    let isInitiator = false;
    let isConnected = false;
    let maxClients = 2;
    let totalClients = 0;
    let peerConnections = new Map();
    let dataChannels = new Map();
    let connectionTimeouts = new Map();
    let retryCounts = new Map();
    const maxRetries = 2;
    let candidatesQueues = new Map();
    let processedMessageIds = new Set();
    let processedAnswers = new Set();
    let username = null;
    let usernames = new Map();
    let joinTimeout = null;

    const statusElement = document.getElementById('status');
    const codeDisplayElement = document.getElementById('codeDisplay');
    const initialContainer = document.getElementById('initialContainer');
    const usernameContainer = document.getElementById('usernameContainer');
    const connectContainer = document.getElementById('connectContainer');
    const chatContainer = document.getElementById('chatContainer');
    const newSessionButton = document.getElementById('newSessionButton');
    const maxClientsContainer = document.getElementById('maxClientsContainer');
    statusElement.textContent = 'Start a new chat or connect to an existing one';

    const socket = new WebSocket('wss://signaling-server-zc6m.onrender.com');
    console.log('WebSocket created');

    socket.onopen = () => {
      console.log('WebSocket opened');
      statusElement.textContent = 'Start a new chat or connect to an existing one';
    };

    socket.onerror = (error) => {
      statusElement.textContent = 'WebSocket error. Please try again.';
      console.error('WebSocket error:', error);
      connectionTimeouts.forEach((timeout) => clearTimeout(timeout));
    };

    socket.onclose = () => {
      statusElement.textContent = 'WebSocket closed. Please refresh.';
      console.error('WebSocket closed');
      connectionTimeouts.forEach((timeout) => clearTimeout(timeout));
      isInitiator = false;
      maxClientsContainer.classList.add('hidden');
    };

    socket.onmessage = (event) => {
      console.log('Received WebSocket message:', event.data);
      try {
        const message = JSON.parse(event.data);
        console.log('Parsed message:', message);
        if (message.type === 'error') {
          statusElement.textContent = message.message;
          console.error('Server error:', message.message);
          if (message.message.includes('Chat is full') || message.message.includes('Username already taken')) {
            socket.close();
            initialContainer.classList.remove('hidden');
            usernameContainer.classList.add('hidden');
            connectContainer.classList.add('hidden');
            codeDisplayElement.classList.add('hidden');
            chatContainer.classList.add('hidden');
            newSessionButton.classList.add('hidden');
            maxClientsContainer.classList.add('hidden');
            clearTimeout(joinTimeout);
          }
          return;
        }
        if (message.type === 'init') {
          clientId = message.clientId;
          maxClients = message.maxClients;
          isInitiator = message.isInitiator;
          totalClients = 1;
          console.log(`Initialized client ${clientId}, username: ${username}, maxClients: ${maxClients}, isInitiator: ${isInitiator}`);
          usernames.set(clientId, username);
          console.log(`Set own username: ${username} for client ${clientId}, usernames: ${[...usernames.entries()]}`);
          initializeMaxClientsUI();
          updateMaxClientsUI();
        }
        if (message.type === 'initiator-changed') {
          console.log(`Initiator changed to ${message.newInitiator} for code: ${code}`);
          isInitiator = message.newInitiator === clientId;
          initializeMaxClientsUI();
          updateMaxClientsUI();
        }
        if (message.type === 'join-notify' && message.code === code) {
          totalClients = message.totalClients;
          console.log(`Join-notify received for code: ${code}, client: ${message.clientId}, total: ${totalClients}, maxClients: ${maxClients}, username: ${message.username}`);
          if (message.username) {
            usernames.set(message.clientId, message.username);
            console.log(`Updated usernames: ${message.clientId} -> ${message.username}, usernames: ${[...usernames.entries()]}`);
          }
          updateMaxClientsUI();
          clearTimeout(joinTimeout);
          if (isInitiator && message.clientId !== clientId && !peerConnections.has(message.clientId)) {
            console.log(`Initiating peer connection with client ${message.clientId}`);
            startPeerConnection(message.clientId, true);
          }
        }
        if (message.type === 'client-disconnected') {
          totalClients = message.totalClients;
          console.log(`Client ${message.clientId} disconnected from code: ${code}, total: ${totalClients}`);
          usernames.delete(message.clientId);
          console.log(`Removed username for client ${message.clientId}, usernames: ${[...usernames.entries()]}`);
          cleanupPeerConnection(message.clientId);
          updateMaxClientsUI();
        }
        if (message.type === 'max-clients') {
          maxClients = message.maxClients;
          console.log(`Max clients updated to ${maxClients} for code: ${code}`);
          updateMaxClientsUI();
        }
        if (message.type === 'offer' && message.clientId !== clientId) {
          console.log(`Received offer from ${message.clientId} for code: ${code}, offer SDP: ${message.offer.sdp.substring(0, 100)}...`);
          handleOffer(message.offer, message.clientId);
        }
        if (message.type === 'answer' && message.clientId !== clientId) {
          console.log(`Received answer from ${message.clientId} for code: ${code}, answer SDP: ${message.answer.sdp.substring(0, 100)}...`);
          handleAnswer(message.answer, message.clientId);
        }
        if (message.type === 'candidate' && message.clientId !== clientId) {
          console.log(`Received ICE candidate from ${message.clientId} for code: ${code}, candidate: ${JSON.stringify(message.candidate)}`);
          handleCandidate(message.candidate, message.clientId);
        }
      } catch (error) {
        console.error('Error parsing message:', error);
      }
    };

    function initializeMaxClientsUI() {
      const maxClientsRadios = document.getElementById('maxClientsRadios');
      maxClientsRadios.innerHTML = '';
      if (isInitiator) {
        maxClientsContainer.classList.remove('hidden');
        for (let n = 2; n <= 10; n++) {
          const label = document.createElement('label');
          label.className = 'text-white flex items-center';
          const input = document.createElement('input');
          input.type = 'radio';
          input.name = 'maxClients';
          input.value = n;
          input.className = 'mr-2';
          input.checked = n === maxClients;
          input.addEventListener('change', () => {
            if (isInitiator) {
              setMaxClients(n);
            } else {
              console.log(`Cannot set max clients to ${n}: not initiator`);
            }
          });
          const span = document.createElement('span');
          span.textContent = n;
          label.appendChild(input);
          label.appendChild(span);
          maxClientsRadios.appendChild(label);
        }
      } else {
        maxClientsContainer.classList.add('hidden');
        console.log('Hiding maxClientsContainer: not initiator');
      }
    }

    function updateMaxClientsUI() {
      statusElement.textContent = isConnected ? `Connected (${totalClients}/${maxClients} users)` : 'Waiting for connection...';
      const inputs = document.querySelectorAll('input[name="maxClients"]');
      inputs.forEach(input => {
        input.checked = parseInt(input.value) === maxClients;
        input.disabled = !isInitiator;
      });
      maxClientsContainer.classList.toggle('hidden', !isInitiator);
    }

    function setMaxClients(n) {
      if (isInitiator && clientId && socket.readyState === WebSocket.OPEN) {
        maxClients = n;
        console.log(`Initiator ${clientId} setting max clients to ${n} for code: ${code}`);
        socket.send(JSON.stringify({ type: 'set-max-clients', maxClients: n, code }));
        updateMaxClientsUI();
      } else {
        console.log(`Cannot set max clients to ${n}: isInitiator=${isInitiator}, clientId=${clientId}, socket.readyState=${socket.readyState}`);
      }
    }

    function startPeerConnection(targetId, isOfferer) {
      console.log(`Starting peer connection with ${targetId} for code: ${code}, offerer: ${isOfferer}`);
      if (peerConnections.has(targetId)) {
        console.log(`Cleaning up existing connection with ${targetId}`);
        cleanupPeerConnection(targetId);
      }
      const peerConnection = new RTCPeerConnection({
        iceServers: [
          { urls: 'stun:stun.l.google.com:19302' },
          { urls: 'stun:stun1.l.google.com:19302' },
          { urls: 'stun:stun.stunprotocol.org:3478' },
          { urls: 'stun:stun.nextcloud.com:443' },
          {
            urls: [
              'turn:global.relay.metered.ca:80',
              'turn:global.relay.metered.ca:443',
              'turn:global.relay.metered.ca:80?transport=tcp',
              'turns:global.relay.metered.ca:443?transport=tcp'
            ],
            username: '8008f3d422fbe49ca4157b23',
            credential: 'E7rLb3LegFMDdjem'
          },
          {
            urls: [
              'turn:relay1.expressturn.com:3480',
              'turn:relay1.expressturn.com:3480?transport=tcp'
            ],
            username: '000000002066560922',
            credential: 'KbPraDRQJfdBPGf4zBA7GJp31qY='
          }
        ],
        iceTransportPolicy: 'all'
      });
      peerConnections.set(targetId, peerConnection);
      candidatesQueues.set(targetId, []);

      let dataChannel;
      if (isOfferer) {
        dataChannel = peerConnection.createDataChannel('chat');
        console.log(`Created data channel for ${targetId}`);
        setupDataChannel(dataChannel, targetId);
        dataChannels.set(targetId, dataChannel);
      }

      peerConnection.onicecandidate = (event) => {
        if (event.candidate) {
          console.log(`Sending ICE candidate to ${targetId} for code: ${code}: ${JSON.stringify(event.candidate)}`);
          socket.send(JSON.stringify({ type: 'candidate', candidate: event.candidate, code, targetId }));
        } else {
          console.log(`No more ICE candidates for ${targetId}`);
        }
      };

      peerConnection.onicecandidateerror = (event) => {
        console.error(`ICE candidate error for ${targetId}: address=${event.address}, port=${event.port}, errorCode=${event.errorCode}, errorText=${event.errorText}, url=${event.url}, network=${navigator.connection?.type || 'unknown'}`);
      };

      peerConnection.onicegatheringstatechange = () => {
        console.log(`ICE gathering state for ${targetId}: ${peerConnection.iceGatheringState}`);
      };

      peerConnection.onconnectionstatechange = () => {
        console.log(`Connection state for ${targetId}: ${peerConnection.connectionState}`);
        if (peerConnection.connectionState === 'disconnected' || peerConnection.connectionState === 'failed') {
          console.error(`Connection failed with ${targetId}: ${peerConnection.connectionState}`);
          statusElement.textContent = 'Connection failed. Retrying...';
          cleanupPeerConnection(targetId);
          const retryCount = retryCounts.get(targetId) || 0;
          if (retryCount < maxRetries) {
            retryCounts.set(targetId, retryCount + 1);
            console.log(`Retrying connection attempt ${retryCount + 1} with ${targetId}`);
            startPeerConnection(targetId, isOfferer);
          } else {
            statusElement.textContent = 'Connection failed after retries. Please try a new session.';
          }
        } else if (peerConnection.connectionState === 'connected') {
          console.log(`WebRTC connection established with ${targetId} for code: ${code}`);
          isConnected = true;
          retryCounts.delete(targetId);
          clearTimeout(connectionTimeouts.get(targetId));
          updateMaxClientsUI();
        }
      };

      peerConnection.ondatachannel = (event) => {
        console.log(`Received data channel from ${targetId}`);
        if (dataChannels.has(targetId)) {
          console.log(`Closing existing data channel for ${targetId}`);
          const existingChannel = dataChannels.get(targetId);
          existingChannel.onmessage = null;
          existingChannel.onopen = null;
          existingChannel.onerror = null;
          existingChannel.onclose = null;
          existingChannel.close();
        }
        dataChannel = event.channel;
        setupDataChannel(dataChannel, targetId);
        dataChannels.set(targetId, dataChannel);
      };

      if (isOfferer) {
        peerConnection.createOffer().then(offer => {
          console.log(`Created offer for ${targetId}: ${offer.sdp.substring(0, 100)}...`);
          return peerConnection.setLocalDescription(offer);
        }).then(() => {
          console.log(`Local description set for ${targetId}`);
          socket.send(JSON.stringify({ type: 'offer', offer: peerConnection.localDescription, code, targetId }));
          const iceTimeout = setTimeout(() => {
            console.log(`ICE gathering timeout for ${targetId}`);
          }, 10000);
          const queue = candidatesQueues.get(targetId) || [];
          queue.forEach(item => {
            if (item.type === 'answer') {
              handleAnswer(item.answer, targetId);
            }
          });
        }).catch(error => {
          console.error(`Error creating offer for ${targetId}:`, error);
          statusElement.textContent = 'Failed to create offer. Please try again.';
        });
      }

      const timeout = setTimeout(() => {
        if (!dataChannels.get(targetId) || dataChannels.get(targetId).readyState !== 'open') {
          console.log(`Connection timed out with ${targetId} for code: ${code}`);
          cleanupPeerConnection(targetId);
          const retryCount = retryCounts.get(targetId) || 0;
          if (retryCount < maxRetries) {
            retryCounts.set(targetId, retryCount + 1);
            console.log(`Retrying connection attempt ${retryCount + 1} with ${targetId}`);
            startPeerConnection(targetId, isOfferer);
          } else {
            statusElement.textContent = 'Connection failed after retries. Please try a new session.';
          }
        }
      }, 10000);
      connectionTimeouts.set(targetId, timeout);
    }

    function setupDataChannel(dataChannel, targetId) {
      dataChannel.onmessage = null;
      dataChannel.onopen = null;
      dataChannel.onerror = null;
      dataChannel.onclose = () => {};

      dataChannel.onopen = () => {
        console.log(`Data channel opened with ${targetId} for code: ${code}, state: ${dataChannel.readyState}`);
        isConnected = true;
        initialContainer.classList.add('hidden');
        usernameContainer.classList.add('hidden');
        connectContainer.classList.add('hidden');
        chatContainer.classList.remove('hidden');
        newSessionButton.classList.remove('hidden');
        clearTimeout(connectionTimeouts.get(targetId));
        retryCounts.delete(targetId);
        updateMaxClientsUI();
      };

      dataChannel.onmessage = (event) => {
        let data;
        try {
          data = JSON.parse(event.data);
        } catch (e) {
          console.error(`Invalid message format from ${targetId}:`, event.data);
          return;
        }
        if (!data.messageId || !data.content || !data.username) {
          console.log(`Missing messageId, content, or username from ${targetId}:`, data);
          return;
        }
        if (processedMessageIds.has(data.messageId)) {
          console.log(`Duplicate message ${data.messageId} from ${targetId}, ignoring`);
          return;
        }
        processedMessageIds.add(data.messageId);
        const senderUsername = usernames.get(targetId) || data.username;
        console.log(`Received message ${data.messageId} from ${senderUsername} (${targetId}):`, data.content);
        const messages = document.getElementById('messages');
        const isSelf = senderUsername === username;
        const className = isSelf ? 'text-blue-600' : 'text-gray-600';
        messages.innerHTML += `<div class="${className}">${senderUsername}: ${data.content}</div>`;
        messages.scrollTop = messages.scrollHeight;
        if (isInitiator) {
          dataChannels.forEach((dc, id) => {
            if (id !== targetId && dc.readyState === 'open' && dc !== dataChannel) {
              console.log(`Relaying message ${data.messageId} to ${id} as ${senderUsername}:`, data.content);
              dc.send(JSON.stringify(data));
            }
          });
        }
      };

      dataChannel.onerror = (error) => {
        console.error(`Data channel error with ${targetId}:`, error);
      };

      dataChannel.onclose = () => {
        console.log(`Data channel closed with ${targetId}`);
        cleanupPeerConnection(targetId);
      };
    }

    async function handleOffer(offer, targetId) {
      console.log(`Handling offer from ${targetId} for code: ${code}, offer SDP: ${offer.sdp.substring(0, 100)}...`);
      if (offer.type !== 'offer') {
        console.error(`Received invalid offer type from ${targetId}:`, offer.type);
        return;
      }
      if (!peerConnections.has(targetId)) {
        console.log(`No existing peer connection for ${targetId}, starting new one`);
        startPeerConnection(targetId, false);
      }
      const peerConnection = peerConnections.get(targetId);
      try {
        await peerConnection.setRemoteDescription(new RTCSessionDescription(offer));
        console.log(`Successfully set remote description for offer from ${targetId}`);
        const answer = await peerConnection.createAnswer();
        console.log(`Created answer for ${targetId}: ${answer.sdp.substring(0, 100)}...`);
        await peerConnection.setLocalDescription(answer);
        console.log(`Sending answer to ${targetId} for code: ${code}, answer SDP: ${peerConnection.localDescription.sdp.substring(0, 100)}...`);
        socket.send(JSON.stringify({ type: 'answer', answer: peerConnection.localDescription, code, targetId }));
        const queue = candidatesQueues.get(targetId) || [];
        queue.forEach(candidate => {
          handleCandidate(candidate, targetId);
        });
        candidatesQueues.set(targetId, []);
      } catch (error) {
        console.error(`Error handling offer from ${targetId}:`, error);
        statusElement.textContent = 'Failed to process offer. Please try again.';
      }
    }

    async function handleAnswer(answer, targetId) {
      console.log(`Handling answer from ${targetId} for code: ${code}, answer SDP: ${answer.sdp.substring(0, 100)}...`);
      const peerConnection = peerConnections.get(targetId);
      if (!peerConnection) {
        console.warn(`No peer connection for ${targetId}, ignoring answer`);
        return;
      }
      if (answer.type !== 'answer') {
        console.error(`Received invalid answer type from ${targetId}:`, answer.type);
        return;
      }
      const answerKey = `${targetId}-${answer.sdp.substring(0, 50)}`;
      if (processedAnswers.has(answerKey)) {
        console.log(`Duplicate answer from ${targetId} ignored`);
        return;
      }
      if (peerConnection.signalingState !== 'have-local-offer') {
        console.log(`Queuing answer from ${targetId}: signalingState=${peerConnection.signalingState}, expected have-local-offer`);
        candidatesQueues.get(targetId).push({ type: 'answer', answer });
        return;
      }
      processedAnswers.add(answerKey);
      try {
        await peerConnection.setRemoteDescription(new RTCSessionDescription(answer));
        console.log(`Successfully set remote description for answer from ${targetId}`);
        const queue = candidatesQueues.get(targetId) || [];
        queue.forEach(item => {
          if (item.type === 'candidate') {
            handleCandidate(item.candidate, targetId);
          }
        });
        candidatesQueues.set(targetId, []);
      } catch (error) {
        console.error(`Error setting remote description for answer from ${targetId}:`, error);
        statusElement.textContent = 'Failed to process answer. Please try again.';
      }
    }

    function handleCandidate(candidate, targetId) {
      console.log(`Handling ICE candidate from ${targetId} for code: ${code}, candidate: ${JSON.stringify(candidate)}`);
      const peerConnection = peerConnections.get(targetId);
      if (peerConnection && peerConnection.remoteDescription) {
        peerConnection.addIceCandidate(new RTCIceCandidate(candidate)).then(() => {
          console.log(`Successfully added ICE candidate from ${targetId}`);
        }).catch(error => {
          console.error(`Error adding ICE candidate from ${targetId}:`, error);
        });
      } else {
        console.log(`Queuing ICE candidate for ${targetId}`);
        const queue = candidatesQueues.get(targetId) || [];
        queue.push(candidate);
        candidatesQueues.set(targetId, queue);
      }
    }

    function cleanupPeerConnection(targetId) {
      const peerConnection = peerConnections.get(targetId);
      if (peerConnection) {
        peerConnection.close();
        peerConnections.delete(targetId);
        console.log(`Closed peer connection with ${targetId}`);
      }
      const dataChannel = dataChannels.get(targetId);
      if (dataChannel) {
        dataChannel.onmessage = null;
        dataChannel.onopen = null;
        dataChannel.onerror = null;
        dataChannel.onclose = null;
        dataChannel.close();
        dataChannels.delete(targetId);
        console.log(`Closed data channel with ${targetId}`);
      }
      candidatesQueues.delete(targetId);
      clearTimeout(connectionTimeouts.get(targetId));
      connectionTimeouts.delete(targetId);
      retryCounts.delete(targetId);
      isConnected = dataChannels.size > 0;
      updateMaxClientsUI();
    }

    function sendMessage(content) {
      if (content && dataChannels.size > 0 && username) {
        try {
          const messageId = generateMessageId();
          const message = { messageId, content, username };
          console.log(`Broadcasting message ${messageId} from ${username}:`, content);
          dataChannels.forEach((dataChannel, targetId) => {
            if (dataChannel.readyState === 'open') {
              dataChannel.send(JSON.stringify(message));
              console.log(`Sent message ${messageId} to ${targetId}, state: ${dataChannel.readyState}`);
            } else {
              console.log(`Skipped sending to ${targetId}, state: ${dataChannel.readyState}`);
            }
          });
          const messages = document.getElementById('messages');
          messages.innerHTML += `<div class="text-blue-600">${username}: ${content}</div>`;
          messages.scrollTop = messages.scrollHeight;
          document.getElementById('messageInput').value = '';
          processedMessageIds.add(messageId);
        } catch (error) {
          console.error('Error broadcasting message:', error);
        }
      } else {
        console.log(`Cannot send message: username=${username}, dataChannels.size=${dataChannels.size}`);
        statusElement.textContent = 'Error: Username not set or no connections. Please reconnect.';
      }
    }

    document.getElementById('startChatToggleButton').onclick = () => {
      initialContainer.classList.add('hidden');
      usernameContainer.classList.remove('hidden');
      statusElement.textContent = 'Enter a username to start a chat';
    };

    document.getElementById('connectToggleButton').onclick = () => {
      initialContainer.classList.add('hidden');
      connectContainer.classList.remove('hidden');
      statusElement.textContent = 'Enter a username and code to join a chat';
    };

    document.getElementById('startChatButton').onclick = () => {
      const usernameInput = document.getElementById('usernameInput').value.trim();
      if (!validateUsername(usernameInput)) {
        statusElement.textContent = 'Invalid username: 1-16 alphanumeric characters required.';
        return;
      }
      username = usernameInput;
      codeDisplayElement.textContent = `Your code: ${code}`;
      codeDisplayElement.classList.remove('hidden');
      usernameContainer.classList.add('hidden');
      connectContainer.classList.add('hidden');
      initialContainer.classList.add('hidden');
      statusElement.textContent = 'Waiting for connection...';
      console.log(`Starting chat with username: ${username}, code: ${code}`);
      socket.send(JSON.stringify({ type: 'join', code, username }));
      joinTimeout = setTimeout(() => {
        console.log(`Join timeout: no other clients joined code ${code}`);
        statusElement.textContent = 'No one joined. Try a new session.';
        newSessionButton.click();
      }, 10000);
    };

    document.getElementById('connectButton').onclick = () => {
      const usernameInput = document.getElementById('usernameConnectInput').value.trim();
      const inputCode = document.getElementById('codeInput').value.trim();
      if (!validateUsername(usernameInput)) {
        statusElement.textContent = 'Invalid username: 1-16 alphanumeric characters required.';
        return;
      }
      if (!validateCode(inputCode)) {
        statusElement.textContent = 'Invalid code format: use xxxx-xxxx-xxxx-xxxx.';
        return;
      }
      username = usernameInput;
      code = inputCode;
      codeDisplayElement.textContent = `Using code: ${code}`;
      codeDisplayElement.classList.remove('hidden');
      initialContainer.classList.add('hidden');
      usernameContainer.classList.add('hidden');
      connectContainer.classList.add('hidden');
      statusElement.textContent = 'Connecting...';
      console.log(`Connecting with username: ${username}, code: ${code}`);
      socket.send(JSON.stringify({ type: 'join', code, username }));
      joinTimeout = setTimeout(() => {
        console.log(`Join timeout: failed to connect to code ${code}`);
        statusElement.textContent = 'Connection failed. Try a new session.';
        newSessionButton.click();
      }, 10000);
    };

    document.getElementById('backButton').onclick = () => {
      usernameContainer.classList.add('hidden');
      initialContainer.classList.remove('hidden');
      statusElement.textContent = 'Start a new chat or connect to an existing one';
      clearTimeout(joinTimeout);
    };

    document.getElementById('backButtonConnect').onclick = () => {
      connectContainer.classList.add('hidden');
      initialContainer.classList.remove('hidden');
      statusElement.textContent = 'Start a new chat or connect to an existing one';
      clearTimeout(joinTimeout);
    };

    document.getElementById('sendButton').onclick = () => {
      const messageInput = document.getElementById('messageInput');
      const message = messageInput.value;
      sendMessage(message);
    };

    document.getElementById('messageInput').addEventListener('keydown', (event) => {
      if (event.key === 'Enter') {
        event.preventDefault();
        const message = event.target.value;
        sendMessage(message);
      }
    });

    document.getElementById('newSessionButton').onclick = () => {
      peerConnections.forEach((pc) => pc.close());
      dataChannels.forEach((dc) => dc.close());
      peerConnections.clear();
      dataChannels.clear();
      candidatesQueues.clear();
      connectionTimeouts.forEach((timeout) => clearTimeout(timeout));
      connectionTimeouts.clear();
      retryCounts.clear();
      processedMessageIds.clear();
      processedAnswers.clear();
      usernames.clear();
      username = null;
      isConnected = false;
      isInitiator = false;
      maxClients = 2;
      totalClients = 0;
      code = generateCode();
      clientId = '';
      codeDisplayElement.textContent = '';
      codeDisplayElement.classList.add('hidden');
      statusElement.textContent = 'Start a new chat or connect to an existing one';
      console.log('New session started');
      document.getElementById('messages').innerHTML = '';
      document.getElementById('messageInput').value = '';
      document.getElementById('usernameInput').value = '';
      document.getElementById('usernameConnectInput').value = '';
      document.getElementById('codeInput').value = '';
      initialContainer.classList.remove('hidden');
      usernameContainer.classList.add('hidden');
      connectContainer.classList.add('hidden');
      chatContainer.classList.add('hidden');
      newSessionButton.classList.add('hidden');
      maxClientsContainer.classList.add('hidden');
      socket.send(JSON.stringify({ type: 'join' }));
    };

    document.getElementById('usernameInput').addEventListener('keydown', (event) => {
      if (event.key === 'Enter') {
        event.preventDefault();
        document.getElementById('startChatButton').click();
      }
    });

    document.getElementById('usernameConnectInput').addEventListener('keydown', (event) => {
      if (event.key === 'Enter') {
        event.preventDefault();
        document.getElementById('codeInput').focus();
      }
    });

    document.getElementById('codeInput').addEventListener('keydown', (event) => {
      if (event.key === 'Enter') {
        event.preventDefault();
        document.getElementById('connectButton').click();
      }
    });
  </script>
</body>
</html>
